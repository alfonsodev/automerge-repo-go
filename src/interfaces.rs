use crossbeam_channel::Sender;
use uuid::Uuid;

#[derive(Debug, Eq, Hash, PartialEq, Clone)]
pub struct DocumentId(pub Uuid);

#[derive(Debug, Eq, Hash, PartialEq, Clone)]
pub struct CollectionId(pub Uuid);

/// Events sent by the network adapter.
#[derive(Debug)]
pub enum NetworkEvent {
    /// A peer sent us the "full data" for the doc,
    /// which will set the doc handle state to ready.
    DocFullData(DocumentId),
}

/// A sink for events generated by the network adapter.
#[derive(Debug)]
pub struct RepoNetworkSink {
    collection_id: CollectionId,
    network_sender: Sender<(CollectionId, NetworkEvent)>,
}

impl RepoNetworkSink {
    pub(crate) fn new(
        network_sender: Sender<(CollectionId, NetworkEvent)>,
        collection_id: CollectionId,
    ) -> Self {
        RepoNetworkSink {
            network_sender,
            collection_id,
        }
    }

    /// Guaranteed not to block if called after having received,
    /// a `sink_wants_events` call on the adapter.
    /// Could be done with batches instead
    pub fn send_event(&self, event: NetworkEvent) {
        self.network_sender
            .send((self.collection_id.clone(), event))
            .expect("Failed to send network event.");
    }
}

pub trait NetworkAdapter: Send {
    fn send_message(&self);

    /// Called by the repo whenever the sink is ready to receive events.
    fn sink_wants_events(&self);

    /// Called by the repo when the collection is created,
    /// client code should hook up the sink so that events can be sent on it.
    fn plug_into_sink(&self, sink: RepoNetworkSink);
}

pub trait StorageAdapter: Send {
    fn save_document(&self, document: ());
}
