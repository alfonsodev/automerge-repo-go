{"version":3,"file":"main.js","sources":["../node_modules/@automerge/automerge/dist/automerge.wasm?url","../node_modules/@automerge/automerge/dist/mjs/constants.js","../node_modules/@automerge/automerge/dist/mjs/counter.js","../node_modules/@automerge/automerge/dist/mjs/immutable_string.js","../node_modules/@automerge/automerge/dist/mjs/proxies.js","../node_modules/@automerge/automerge/dist/mjs/wasm_bindgen_output/web/automerge_wasm.js","../node_modules/@automerge/automerge/dist/mjs/low_level.js","../node_modules/@automerge/automerge/dist/mjs/internal_state.js","../node_modules/@automerge/automerge/dist/mjs/implementation.js","../node_modules/ms/index.js","../node_modules/debug/src/common.js","../node_modules/debug/src/browser.js","../node_modules/eventemitter3/index.js","../node_modules/xstate/dev/dist/xstate-dev.esm.js","../node_modules/xstate/dist/raise-b0a4e862.esm.js","../node_modules/xstate/dist/assign-c3259787.esm.js","../node_modules/xstate/dist/StateMachine-c88ea5dd.esm.js","../node_modules/xstate/dist/xstate.esm.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/rng.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/regex.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/validate.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/parse.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/native.js","../node_modules/@automerge/automerge-repo/node_modules/uuid/dist/esm-browser/v4.js","../node_modules/@noble/hashes/crypto.js","../node_modules/@noble/hashes/utils.js","../node_modules/@noble/hashes/_md.js","../node_modules/@noble/hashes/_u64.js","../node_modules/@noble/hashes/sha2.js","../node_modules/@noble/hashes/sha256.js","../node_modules/base-x/src/index.js","../node_modules/bs58/index.js","../node_modules/bs58check/base.js","../node_modules/bs58check/index.js","../node_modules/@automerge/automerge-repo/dist/helpers/bufferFromHex.js","../node_modules/@automerge/automerge-repo/dist/AutomergeUrl.js","../node_modules/cbor-x/decode.js","../node_modules/cbor-x/encode.js","../node_modules/@automerge/automerge-repo/dist/helpers/cbor.js","../node_modules/@automerge/automerge-repo/dist/helpers/arraysAreEqual.js","../node_modules/@automerge/automerge-repo/dist/helpers/headsAreSame.js","../node_modules/@automerge/automerge-repo/dist/helpers/withTimeout.js","../node_modules/@automerge/automerge-repo/dist/DocHandle.js","../node_modules/@automerge/automerge-repo/dist/RemoteHeadsSubscriptions.js","../node_modules/@automerge/automerge-repo/dist/helpers/throttle.js","../node_modules/@automerge/automerge-repo/dist/network/messages.js","../node_modules/@automerge/automerge-repo/dist/network/NetworkSubsystem.js","../node_modules/@automerge/automerge-repo/dist/helpers/mergeArrays.js","../node_modules/fast-sha256/sha256.js","../node_modules/@automerge/automerge-repo/dist/storage/keyHash.js","../node_modules/@automerge/automerge-repo/dist/storage/StorageSubsystem.js","../node_modules/@automerge/automerge-repo/dist/synchronizer/Synchronizer.js","../node_modules/@automerge/automerge-repo/dist/synchronizer/DocSynchronizer.js","../node_modules/@automerge/automerge-repo/dist/synchronizer/CollectionSynchronizer.js","../node_modules/@automerge/automerge-repo/dist/helpers/abortable.js","../node_modules/@automerge/automerge-repo/dist/Repo.js","../node_modules/@automerge/automerge-repo/dist/network/NetworkAdapter.js","../node_modules/@automerge/automerge-repo-storage-indexeddb/dist/index.js","../node_modules/isomorphic-ws/browser.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/messages.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/protocolVersion.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/assert.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/toArrayBuffer.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/WebSocketClientAdapter.js","../node_modules/@automerge/automerge-repo-network-websocket/dist/WebSocketServerAdapter.js","../src/js/app.js"],"sourcesContent":["export default \"__VITE_ASSET__CR3pA46E__\"","// Properties of the document root object\nexport const STATE = Symbol.for(\"_am_meta\"); // symbol used to hide application metadata on automerge objects\nexport const TRACE = Symbol.for(\"_am_trace\"); // used for debugging\nexport const OBJECT_ID = Symbol.for(\"_am_objectId\"); // symbol used to hide the object id on automerge objects\nexport const IS_PROXY = Symbol.for(\"_am_isProxy\"); // symbol used to test if the document is a proxy object\nexport const CLEAR_CACHE = Symbol.for(\"_am_clearCache\"); // symbol used to tell a proxy object to clear its cache\nexport const UINT = Symbol.for(\"_am_uint\");\nexport const INT = Symbol.for(\"_am_int\");\nexport const F64 = Symbol.for(\"_am_f64\");\nexport const COUNTER = Symbol.for(\"_am_counter\");\nexport const TEXT = Symbol.for(\"_am_text\");\nexport const IMMUTABLE_STRING = Symbol.for(\"_am_immutableString\");\n","import { COUNTER } from \"./constants.js\";\n/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nexport class Counter {\n    constructor(value) {\n        this.value = value || 0;\n        Reflect.defineProperty(this, COUNTER, { value: true });\n    }\n    /**\n     * A peculiar JavaScript language feature from its early days: if the object\n     * `x` has a `valueOf()` method that returns a number, you can use numerical\n     * operators on the object `x` directly, such as `x + 1` or `x < 4`.\n     * This method is also called when coercing a value to a string by\n     * concatenating it with another string, as in `x + ''`.\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n     */\n    valueOf() {\n        return this.value;\n    }\n    /**\n     * Returns the counter value as a decimal string. If `x` is a counter object,\n     * this method is called e.g. when you do `['value: ', x].join('')` or when\n     * you use string interpolation: `value: ${x}`.\n     */\n    toString() {\n        return this.valueOf().toString();\n    }\n    /**\n     * Returns the counter value, so that a JSON serialization of an Automerge\n     * document represents the counter simply as an integer.\n     */\n    toJSON() {\n        return this.value;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    increment(_delta) {\n        throw new Error(\"Counters should not be incremented outside of a change callback\");\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    decrement(_delta) {\n        throw new Error(\"Counters should not be decremented outside of a change callback\");\n    }\n}\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n    constructor(value, context, path, objectId, key) {\n        super(value);\n        this.context = context;\n        this.path = path;\n        this.objectId = objectId;\n        this.key = key;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     */\n    increment(delta) {\n        delta = typeof delta === \"number\" ? delta : 1;\n        this.context.increment(this.objectId, this.key, delta);\n        this.value += delta;\n        return this.value;\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     */\n    decrement(delta) {\n        return this.increment(typeof delta === \"number\" ? -delta : -1);\n    }\n}\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n */\nexport function getWriteableCounter(value, context, path, objectId, key) {\n    return new WriteableCounter(value, context, path, objectId, key);\n}\n//module.exports = { Counter, getWriteableCounter }\n","var _a;\nimport { IMMUTABLE_STRING } from \"./constants.js\";\nexport class ImmutableString {\n    constructor(val) {\n        // Used to detect whether a value is a ImmutableString object rather than using an instanceof check\n        this[_a] = true;\n        this.val = val;\n    }\n    /**\n     * Returns the content of the ImmutableString object as a simple string\n     */\n    toString() {\n        return this.val;\n    }\n    toJSON() {\n        return this.val;\n    }\n}\n_a = IMMUTABLE_STRING;\n","import { getWriteableCounter } from \"./counter.js\";\nimport { STATE, TRACE, IS_PROXY, OBJECT_ID, CLEAR_CACHE, COUNTER, INT, UINT, F64, IMMUTABLE_STRING, TEXT, } from \"./constants.js\";\nimport { ImmutableString } from \"./immutable_string.js\";\nfunction parseListIndex(key) {\n    if (typeof key === \"string\" && /^[0-9]+$/.test(key))\n        key = parseInt(key, 10);\n    if (typeof key !== \"number\") {\n        return key;\n    }\n    if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n        throw new RangeError(\"A list index must be positive, but you passed \" + key);\n    }\n    return key;\n}\nfunction valueAt(target, prop) {\n    const { context, objectId, path } = target;\n    const value = context.getWithType(objectId, prop);\n    if (value === null) {\n        return;\n    }\n    const datatype = value[0];\n    const val = value[1];\n    switch (datatype) {\n        case undefined:\n            return;\n        case \"map\":\n            return mapProxy(context, val, [...path, prop]);\n        case \"list\":\n            return listProxy(context, val, [...path, prop]);\n        case \"text\":\n            return context.text(val);\n        case \"str\":\n            return new ImmutableString(val);\n        case \"uint\":\n            return val;\n        case \"int\":\n            return val;\n        case \"f64\":\n            return val;\n        case \"boolean\":\n            return val;\n        case \"null\":\n            return null;\n        case \"bytes\":\n            return val;\n        case \"timestamp\":\n            return val;\n        case \"counter\": {\n            const counter = getWriteableCounter(val, context, path, objectId, prop);\n            return counter;\n        }\n        default:\n            throw RangeError(`datatype ${datatype} unimplemented`);\n    }\n}\nfunction import_value(value, path, context) {\n    const type = typeof value;\n    switch (type) {\n        case \"object\":\n            if (value == null) {\n                return [null, \"null\"];\n            }\n            else if (value[UINT]) {\n                return [value.value, \"uint\"];\n            }\n            else if (value[INT]) {\n                return [value.value, \"int\"];\n            }\n            else if (value[F64]) {\n                return [value.value, \"f64\"];\n            }\n            else if (value[COUNTER]) {\n                return [value.value, \"counter\"];\n            }\n            else if (value instanceof Date) {\n                return [value.getTime(), \"timestamp\"];\n            }\n            else if (isImmutableString(value)) {\n                return [value.toString(), \"str\"];\n            }\n            else if (value instanceof Uint8Array) {\n                return [value, \"bytes\"];\n            }\n            else if (value instanceof Array) {\n                return [value, \"list\"];\n            }\n            else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n                return [value, \"map\"];\n            }\n            else if (isSameDocument(value, context)) {\n                throw new RangeError(\"Cannot create a reference to an existing document object\");\n            }\n            else {\n                throw new RangeError(`Cannot assign unknown object: ${value}`);\n            }\n        case \"boolean\":\n            return [value, \"boolean\"];\n        case \"number\":\n            if (Number.isInteger(value)) {\n                return [value, \"int\"];\n            }\n            else {\n                return [value, \"f64\"];\n            }\n        case \"string\":\n            return [value, \"text\"];\n        case \"undefined\":\n            throw new RangeError([\n                `Cannot assign undefined value at ${printPath(path)}, `,\n                \"because `undefined` is not a valid JSON data type. \",\n                \"You might consider setting the property's value to `null`, \",\n                \"or using `delete` to remove it altogether.\",\n            ].join(\"\"));\n        default:\n            throw new RangeError([\n                `Cannot assign ${type} value at ${printPath(path)}. `,\n                `All JSON primitive datatypes (object, array, string, number, boolean, null) `,\n                `are supported in an Automerge document; ${type} values are not. `,\n            ].join(\"\"));\n    }\n}\n// When we assign a value to a property in a proxy we recursively walk through\n// the value we are assigning and copy it into the document. This is generally\n// desirable behaviour. However, a very common bug is to accidentally assign a\n// value which is already in the document to another key within the same\n// document, this often leads to surprising behaviour where users expected to\n// _move_ the object, but it is instead copied. To avoid this we check if the\n// value is from the same document and if it is we throw an error, this means\n// we require an explicit Object.assign call to copy the object, thus avoiding\n// the footgun\nfunction isSameDocument(val, context) {\n    var _b, _c;\n    // Date is technically an object, but immutable, so allowing people to assign\n    // a date from one place in the document to another place in the document is\n    // not likely to be a bug\n    if (val instanceof Date) {\n        return false;\n    }\n    // this depends on __wbg_ptr being the wasm pointer\n    // a new version of wasm-bindgen will break this\n    // but the tests should expose the break\n    if (val && ((_c = (_b = val[STATE]) === null || _b === void 0 ? void 0 : _b.handle) === null || _c === void 0 ? void 0 : _c.__wbg_ptr) === context.__wbg_ptr) {\n        return true;\n    }\n    return false;\n}\nconst MapHandler = {\n    get(target, key) {\n        const { context, objectId, cache } = target;\n        if (key === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (key === OBJECT_ID)\n            return objectId;\n        if (key === IS_PROXY)\n            return true;\n        if (key === TRACE)\n            return target.trace;\n        if (key === STATE)\n            return { handle: context };\n        if (!cache[key]) {\n            cache[key] = valueAt(target, key);\n        }\n        return cache[key];\n    },\n    set(target, key, val) {\n        const { context, objectId, path } = target;\n        target.cache = {}; // reset cache on set\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (key === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (key === CLEAR_CACHE) {\n            return true;\n        }\n        const [value, datatype] = import_value(val, [...path, key], context);\n        switch (datatype) {\n            case \"list\": {\n                const list = context.putObject(objectId, key, []);\n                const proxyList = listProxy(context, list, [...path, key]);\n                for (let i = 0; i < value.length; i++) {\n                    proxyList[i] = value[i];\n                }\n                break;\n            }\n            case \"text\": {\n                context.putObject(objectId, key, value);\n                break;\n            }\n            case \"map\": {\n                const map = context.putObject(objectId, key, {});\n                const proxyMap = mapProxy(context, map, [...path, key]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                context.put(objectId, key, value, datatype);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        const { context, objectId } = target;\n        target.cache = {}; // reset cache on delete\n        context.delete(objectId, key);\n        return true;\n    },\n    has(target, key) {\n        const value = this.get(target, key);\n        return value !== undefined;\n    },\n    getOwnPropertyDescriptor(target, key) {\n        // const { context, objectId } = target\n        const value = this.get(target, key);\n        if (typeof value !== \"undefined\") {\n            return {\n                configurable: true,\n                enumerable: true,\n                value,\n            };\n        }\n    },\n    ownKeys(target) {\n        const { context, objectId } = target;\n        // FIXME - this is a tmp workaround until fix the dupe key bug in keys()\n        const keys = context.keys(objectId);\n        return [...new Set(keys)];\n    },\n};\nconst ListHandler = {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return listMethods(target)[index];\n        }\n    },\n    set(target, index, val) {\n        const { context, objectId, path } = target;\n        index = parseListIndex(index);\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (index === CLEAR_CACHE) {\n            return true;\n        }\n        if (index === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (typeof index == \"string\") {\n            throw new RangeError(\"list index must be a number\");\n        }\n        const [value, datatype] = import_value(val, [...path, index], context);\n        switch (datatype) {\n            case \"list\": {\n                let list;\n                if (index >= context.length(objectId)) {\n                    list = context.insertObject(objectId, index, []);\n                }\n                else {\n                    list = context.putObject(objectId, index, []);\n                }\n                const proxyList = listProxy(context, list, [...path, index]);\n                proxyList.splice(0, 0, ...value);\n                break;\n            }\n            case \"text\": {\n                if (index >= context.length(objectId)) {\n                    context.insertObject(objectId, index, value);\n                }\n                else {\n                    context.putObject(objectId, index, value);\n                }\n                break;\n            }\n            case \"map\": {\n                let map;\n                if (index >= context.length(objectId)) {\n                    map = context.insertObject(objectId, index, {});\n                }\n                else {\n                    map = context.putObject(objectId, index, {});\n                }\n                const proxyMap = mapProxy(context, map, [...path, index]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                if (index >= context.length(objectId)) {\n                    context.insert(objectId, index, value, datatype);\n                }\n                else {\n                    context.put(objectId, index, value, datatype);\n                }\n        }\n        return true;\n    },\n    deleteProperty(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        const elem = context.get(objectId, index);\n        if (elem != null && elem[0] == \"counter\") {\n            throw new TypeError(\"Unsupported operation: deleting a counter from a list\");\n        }\n        context.delete(objectId, index);\n        return true;\n    },\n    has(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (typeof index === \"number\") {\n            return index < context.length(objectId);\n        }\n        return index === \"length\";\n    },\n    getOwnPropertyDescriptor(target, index) {\n        const { context, objectId } = target;\n        if (index === \"length\")\n            return { writable: true, value: context.length(objectId) };\n        if (index === OBJECT_ID)\n            return { configurable: false, enumerable: false, value: objectId };\n        index = parseListIndex(index);\n        const value = valueAt(target, index);\n        return { configurable: true, enumerable: true, value };\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target);\n    },\n    ownKeys( /*target*/) {\n        const keys = [];\n        // uncommenting this causes assert.deepEqual() to fail when comparing to a pojo array\n        // but not uncommenting it causes for (i in list) {} to not enumerate values properly\n        //const {context, objectId } = target\n        //for (let i = 0; i < target.context.length(objectId); i++) { keys.push(i.toString()) }\n        keys.push(\"length\");\n        return keys;\n    },\n};\nconst TextHandler = Object.assign({}, ListHandler, {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return textMethods(target)[index] || listMethods(target)[index];\n        }\n    },\n    getPrototypeOf( /*target*/) {\n        return Object.getPrototypeOf(new Text());\n    },\n});\nexport function mapProxy(context, objectId, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    const result = new Proxy(proxied, MapHandler);\n    // conversion through unknown is necessary because the types are so different\n    return result;\n}\nexport function listProxy(context, objectId, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n    };\n    const proxied = [];\n    Object.assign(proxied, target);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new Proxy(proxied, ListHandler);\n}\nexport function textProxy(context, objectId, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    return new Proxy(proxied, TextHandler);\n}\nexport function rootProxy(context) {\n    /* eslint-disable-next-line */\n    return mapProxy(context, \"_root\", []);\n}\nfunction listMethods(target) {\n    const { context, objectId, path } = target;\n    const methods = {\n        at(index) {\n            return valueAt(target, index);\n        },\n        deleteAt(index, numDelete) {\n            if (typeof numDelete === \"number\") {\n                context.splice(objectId, index, numDelete);\n            }\n            else {\n                context.delete(objectId, index);\n            }\n            return this;\n        },\n        fill(val, start, end) {\n            const [value, datatype] = import_value(val, [...path, start], context);\n            const length = context.length(objectId);\n            start = parseListIndex(start || 0);\n            end = parseListIndex(end || length);\n            for (let i = start; i < Math.min(end, length); i++) {\n                if (datatype === \"list\" || datatype === \"map\") {\n                    context.putObject(objectId, i, value);\n                }\n                else if (datatype === \"text\") {\n                    context.putObject(objectId, i, value);\n                }\n                else {\n                    context.put(objectId, i, value, datatype);\n                }\n            }\n            return this;\n        },\n        indexOf(searchElement, start = 0) {\n            const length = context.length(objectId);\n            for (let i = start; i < length; i++) {\n                const valueWithType = context.getWithType(objectId, i);\n                if (!valueWithType) {\n                    continue;\n                }\n                const [valType, value] = valueWithType;\n                // Either the target element is an object, and we return if we have found\n                // the same object or it is a primitive value and we return if it matches\n                // the current value\n                const isObject = [\"map\", \"list\", \"text\"].includes(valType);\n                if (!isObject) {\n                    // If the element is not an object, then check if the value is equal to the target\n                    if (value === searchElement) {\n                        return i;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                // if it's an object, but the type of the search element is a string, then we\n                // need to check if the object is a text object with the same value as the search element\n                if (valType === \"text\" && typeof searchElement === \"string\") {\n                    if (searchElement === valueAt(target, i)) {\n                        return i;\n                    }\n                }\n                // The only possible match now is if the searchElement is an object already in the\n                // automerge document with the same object ID as the value\n                if (searchElement[OBJECT_ID] === value) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        insertAt(index, ...values) {\n            this.splice(index, 0, ...values);\n            return this;\n        },\n        pop() {\n            const length = context.length(objectId);\n            if (length == 0) {\n                return undefined;\n            }\n            const last = valueAt(target, length - 1);\n            context.delete(objectId, length - 1);\n            return last;\n        },\n        push(...values) {\n            const len = context.length(objectId);\n            this.splice(len, 0, ...values);\n            return context.length(objectId);\n        },\n        shift() {\n            if (context.length(objectId) == 0)\n                return;\n            const first = valueAt(target, 0);\n            context.delete(objectId, 0);\n            return first;\n        },\n        splice(index, del, ...vals) {\n            index = parseListIndex(index);\n            // if del is undefined, delete until the end of the list\n            if (typeof del !== \"number\") {\n                del = context.length(objectId) - index;\n            }\n            del = parseListIndex(del);\n            for (const val of vals) {\n                if (isSameDocument(val, context)) {\n                    throw new RangeError(\"Cannot create a reference to an existing document object\");\n                }\n            }\n            const result = [];\n            for (let i = 0; i < del; i++) {\n                const value = valueAt(target, index);\n                if (value !== undefined) {\n                    result.push(value);\n                }\n                context.delete(objectId, index);\n            }\n            const values = vals.map((val, index) => {\n                try {\n                    return import_value(val, [...path], context);\n                }\n                catch (e) {\n                    if (e instanceof RangeError) {\n                        throw new RangeError(`${e.message} (at index ${index} in the input)`);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n            for (const [value, datatype] of values) {\n                switch (datatype) {\n                    case \"list\": {\n                        const list = context.insertObject(objectId, index, []);\n                        const proxyList = listProxy(context, list, [...path, index]);\n                        proxyList.splice(0, 0, ...value);\n                        break;\n                    }\n                    case \"text\": {\n                        context.insertObject(objectId, index, value);\n                        break;\n                    }\n                    case \"map\": {\n                        const map = context.insertObject(objectId, index, {});\n                        const proxyMap = mapProxy(context, map, [...path, index]);\n                        for (const key in value) {\n                            proxyMap[key] = value[key];\n                        }\n                        break;\n                    }\n                    default:\n                        context.insert(objectId, index, value, datatype);\n                }\n                index += 1;\n            }\n            return result;\n        },\n        unshift(...values) {\n            this.splice(0, 0, ...values);\n            return context.length(objectId);\n        },\n        entries() {\n            let i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value: [i++, value], done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        keys() {\n            let i = 0;\n            const len = context.length(objectId);\n            const iterator = {\n                next: () => {\n                    if (i < len) {\n                        return { value: i++, done: false };\n                    }\n                    return { value: undefined, done: true };\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        values() {\n            let i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i++);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value, done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        toArray() {\n            const list = [];\n            let value;\n            do {\n                value = valueAt(target, list.length);\n                if (value !== undefined) {\n                    list.push(value);\n                }\n            } while (value !== undefined);\n            return list;\n        },\n        map(f) {\n            return this.toArray().map(f);\n        },\n        toString() {\n            return this.toArray().toString();\n        },\n        toLocaleString() {\n            return this.toArray().toLocaleString();\n        },\n        forEach(f) {\n            return this.toArray().forEach(f);\n        },\n        // todo: real concat function is different\n        concat(other) {\n            return this.toArray().concat(other);\n        },\n        every(f) {\n            return this.toArray().every(f);\n        },\n        filter(f) {\n            return this.toArray().filter(f);\n        },\n        find(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return v;\n                }\n                index += 1;\n            }\n        },\n        findIndex(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        },\n        includes(elem) {\n            return this.find(e => e === elem) !== undefined;\n        },\n        join(sep) {\n            return this.toArray().join(sep);\n        },\n        reduce(f, initialValue) {\n            return this.toArray().reduce(f, initialValue);\n        },\n        reduceRight(f, initialValue) {\n            return this.toArray().reduceRight(f, initialValue);\n        },\n        lastIndexOf(search, fromIndex = +Infinity) {\n            // this can be faster\n            return this.toArray().lastIndexOf(search, fromIndex);\n        },\n        slice(index, num) {\n            return this.toArray().slice(index, num);\n        },\n        some(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return true;\n                }\n                index += 1;\n            }\n            return false;\n        },\n        [Symbol.iterator]: function* () {\n            let i = 0;\n            let value = valueAt(target, i);\n            while (value !== undefined) {\n                yield value;\n                i += 1;\n                value = valueAt(target, i);\n            }\n        },\n    };\n    return methods;\n}\nfunction textMethods(target) {\n    const { context, objectId } = target;\n    const methods = {\n        set(index, value) {\n            return (this[index] = value);\n        },\n        get(index) {\n            return this[index];\n        },\n        toString() {\n            return context.text(objectId).replace(/￼/g, \"\");\n        },\n        toSpans() {\n            const spans = [];\n            let chars = \"\";\n            const length = context.length(objectId);\n            for (let i = 0; i < length; i++) {\n                const value = this[i];\n                if (typeof value === \"string\") {\n                    chars += value;\n                }\n                else {\n                    if (chars.length > 0) {\n                        spans.push(chars);\n                        chars = \"\";\n                    }\n                    spans.push(value);\n                }\n            }\n            if (chars.length > 0) {\n                spans.push(chars);\n            }\n            return spans;\n        },\n        toJSON() {\n            return this.toString();\n        },\n        indexOf(o, start = 0) {\n            const text = context.text(objectId);\n            return text.indexOf(o, start);\n        },\n        insertAt(index, ...values) {\n            if (values.every(v => typeof v === \"string\")) {\n                context.splice(objectId, index, 0, values.join(\"\"));\n            }\n            else {\n                listMethods(target).insertAt(index, ...values);\n            }\n        },\n    };\n    return methods;\n}\nfunction printPath(path) {\n    // print the path as a json pointer\n    const jsonPointerComponents = path.map(component => {\n        // if its a number just turn it into a string\n        if (typeof component === \"number\") {\n            return component.toString();\n        }\n        else if (typeof component === \"string\") {\n            // otherwise we have to escape `/` and `~` characters\n            return component.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n        }\n    });\n    if (path.length === 0) {\n        return \"\";\n    }\n    else {\n        return \"/\" + jsonPointerComponents.join(\"/\");\n    }\n}\n/*\n * Check if an object is a {@link ImmutableString}\n */\nexport function isImmutableString(obj) {\n    // We used to determine whether something was a ImmutableString by doing an instanceof check, but\n    // this doesn't work if the automerge module is loaded twice somehow. Instead, use the presence\n    // of a symbol to determine if something is a ImmutableString\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        Object.prototype.hasOwnProperty.call(obj, IMMUTABLE_STRING));\n}\nexport function isCounter(obj) {\n    // We used to determine whether something was a Counter by doing an instanceof check, but\n    // this doesn't work if the automerge module is loaded twice somehow. Instead, use the presence\n    // of a symbol to determine if something is a Counter\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        Object.prototype.hasOwnProperty.call(obj, COUNTER));\n}\n/*\n * Check if an object is a {@link Text}\n */\nexport function isText(obj) {\n    // We used to determine whether something was a Text by doing an instanceof check, but\n    // this doesn't work if the automerge module is loaded twice somehow. Instead, use the presence\n    // of a symbol to determine if something is a TEXT\n    return (typeof obj === \"object\" &&\n        obj !== null &&\n        Object.prototype.hasOwnProperty.call(obj, TEXT));\n}\n","let wasm;\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_4.set(idx, obj);\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches && builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_4.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n/**\n * @param {any} options\n * @returns {Automerge}\n */\nexport function create(options) {\n    const ret = wasm.create(options);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return Automerge.__wrap(ret[0]);\n}\n\n/**\n * @param {Uint8Array} data\n * @param {any} options\n * @returns {Automerge}\n */\nexport function load(data, options) {\n    const ret = wasm.load(data, options);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return Automerge.__wrap(ret[0]);\n}\n\n/**\n * @param {any} change\n * @returns {Uint8Array}\n */\nexport function encodeChange(change) {\n    const ret = wasm.encodeChange(change);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n}\n\n/**\n * @param {Uint8Array} change\n * @returns {DecodedChange}\n */\nexport function decodeChange(change) {\n    const ret = wasm.decodeChange(change);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n}\n\n/**\n * @returns {SyncState}\n */\nexport function initSyncState() {\n    const ret = wasm.initSyncState();\n    return SyncState.__wrap(ret);\n}\n\n/**\n * @param {any} state\n * @returns {SyncState}\n */\nexport function importSyncState(state) {\n    const ret = wasm.importSyncState(state);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return SyncState.__wrap(ret[0]);\n}\n\n/**\n * @param {SyncState} state\n * @returns {JsSyncState}\n */\nexport function exportSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.exportSyncState(state.__wbg_ptr);\n    return ret;\n}\n\n/**\n * @param {any} message\n * @returns {SyncMessage}\n */\nexport function encodeSyncMessage(message) {\n    const ret = wasm.encodeSyncMessage(message);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n}\n\n/**\n * @param {Uint8Array} msg\n * @returns {DecodedSyncMessage}\n */\nexport function decodeSyncMessage(msg) {\n    const ret = wasm.decodeSyncMessage(msg);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return takeFromExternrefTable0(ret[0]);\n}\n\n/**\n * @param {SyncState} state\n * @returns {Uint8Array}\n */\nexport function encodeSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.encodeSyncState(state.__wbg_ptr);\n    return ret;\n}\n\n/**\n * @param {Uint8Array} data\n * @returns {SyncState}\n */\nexport function decodeSyncState(data) {\n    const ret = wasm.decodeSyncState(data);\n    if (ret[2]) {\n        throw takeFromExternrefTable0(ret[1]);\n    }\n    return SyncState.__wrap(ret[0]);\n}\n\nconst AutomergeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_automerge_free(ptr >>> 0, 1));\n\nexport class Automerge {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Automerge.prototype);\n        obj.__wbg_ptr = ptr;\n        AutomergeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AutomergeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_automerge_free(ptr, 0);\n    }\n    /**\n     * @param {string | null} [actor]\n     * @returns {Automerge}\n     */\n    static new(actor) {\n        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_new(ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return Automerge.__wrap(ret[0]);\n    }\n    /**\n     * @param {string | null} [actor]\n     * @returns {Automerge}\n     */\n    clone(actor) {\n        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_clone(this.__wbg_ptr, ptr0, len0);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return Automerge.__wrap(ret[0]);\n    }\n    /**\n     * @param {string | null | undefined} actor\n     * @param {any} heads\n     * @returns {Automerge}\n     */\n    fork(actor, heads) {\n        var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_fork(this.__wbg_ptr, ptr0, len0, heads);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return Automerge.__wrap(ret[0]);\n    }\n    /**\n     * @returns {number}\n     */\n    pendingOps() {\n        const ret = wasm.automerge_pendingOps(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {string | null} [message]\n     * @param {number | null} [time]\n     * @returns {Hash | null}\n     */\n    commit(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_commit(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return ret;\n    }\n    /**\n     * @param {Automerge} other\n     * @returns {Heads}\n     */\n    merge(other) {\n        _assertClass(other, Automerge);\n        const ret = wasm.automerge_merge(this.__wbg_ptr, other.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @returns {number}\n     */\n    rollback() {\n        const ret = wasm.automerge_rollback(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {Array<any>}\n     */\n    keys(obj, heads) {\n        const ret = wasm.automerge_keys(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {string}\n     */\n    text(obj, heads) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.automerge_text(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {Array<any>}\n     */\n    spans(obj, heads) {\n        const ret = wasm.automerge_spans(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {number} start\n     * @param {number} delete_count\n     * @param {any} text\n     */\n    splice(obj, start, delete_count, text) {\n        const ret = wasm.automerge_splice(this.__wbg_ptr, obj, start, delete_count, text);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {string} new_text\n     */\n    updateText(obj, new_text) {\n        const ret = wasm.automerge_updateText(this.__wbg_ptr, obj, new_text);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {Span[]} args\n     */\n    updateSpans(obj, args) {\n        const ret = wasm.automerge_updateSpans(this.__wbg_ptr, obj, args);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {any} value\n     * @param {any} datatype\n     */\n    push(obj, value, datatype) {\n        const ret = wasm.automerge_push(this.__wbg_ptr, obj, value, datatype);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {ObjType} value\n     * @returns {ObjID}\n     */\n    pushObject(obj, value) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.automerge_pushObject(this.__wbg_ptr, obj, value);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {number} index\n     * @param {any} value\n     * @param {any} datatype\n     */\n    insert(obj, index, value, datatype) {\n        const ret = wasm.automerge_insert(this.__wbg_ptr, obj, index, value, datatype);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {number} index\n     * @param {{[key: string]: MaterializeValue}} block\n     */\n    splitBlock(obj, index, block) {\n        const ret = wasm.automerge_splitBlock(this.__wbg_ptr, obj, index, block);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {number} index\n     */\n    joinBlock(obj, index) {\n        const ret = wasm.automerge_joinBlock(this.__wbg_ptr, obj, index);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {number} index\n     * @param {{[key: string]: MaterializeValue}} block\n     */\n    updateBlock(obj, index, block) {\n        const ret = wasm.automerge_updateBlock(this.__wbg_ptr, obj, index, block);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {any} text\n     * @param {number} index\n     * @param {Array<any> | null} [heads]\n     * @returns {any}\n     */\n    getBlock(text, index, heads) {\n        const ret = wasm.automerge_getBlock(this.__wbg_ptr, text, index, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {number} index\n     * @param {ObjType} value\n     * @returns {ObjID}\n     */\n    insertObject(obj, index, value) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.automerge_insertObject(this.__wbg_ptr, obj, index, value);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {any} prop\n     * @param {any} value\n     * @param {any} datatype\n     */\n    put(obj, prop, value, datatype) {\n        const ret = wasm.automerge_put(this.__wbg_ptr, obj, prop, value, datatype);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {Prop} prop\n     * @param {ObjType} value\n     * @returns {ObjID}\n     */\n    putObject(obj, prop, value) {\n        const ret = wasm.automerge_putObject(this.__wbg_ptr, obj, prop, value);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {Prop} prop\n     * @param {number} value\n     */\n    increment(obj, prop, value) {\n        const ret = wasm.automerge_increment(this.__wbg_ptr, obj, prop, value);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {any} prop\n     * @param {Array<any> | null} [heads]\n     * @returns {any}\n     */\n    get(obj, prop, heads) {\n        const ret = wasm.automerge_get(this.__wbg_ptr, obj, prop, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {any} prop\n     * @param {Array<any> | null} [heads]\n     * @returns {any}\n     */\n    getWithType(obj, prop, heads) {\n        const ret = wasm.automerge_getWithType(this.__wbg_ptr, obj, prop, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {object}\n     */\n    objInfo(obj, heads) {\n        const ret = wasm.automerge_objInfo(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {any} arg\n     * @param {Array<any> | null} [heads]\n     * @returns {Array<any>}\n     */\n    getAll(obj, arg, heads) {\n        const ret = wasm.automerge_getAll(this.__wbg_ptr, obj, arg, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {boolean} enable\n     * @returns {boolean}\n     */\n    enableFreeze(enable) {\n        const ret = wasm.automerge_enableFreeze(this.__wbg_ptr, enable);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return ret[0] !== 0;\n    }\n    /**\n     * @param {string} datatype\n     * @param {Function} construct\n     * @param {(arg: any) => any | undefined} deconstruct\n     */\n    registerDatatype(datatype, construct, deconstruct) {\n        const ret = wasm.automerge_registerDatatype(this.__wbg_ptr, datatype, construct, deconstruct);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {any} object\n     * @param {any} meta\n     * @returns {any}\n     */\n    applyPatches(object, meta) {\n        const ret = wasm.automerge_applyPatches(this.__wbg_ptr, object, meta);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} object\n     * @param {any} meta\n     * @returns {any}\n     */\n    applyAndReturnPatches(object, meta) {\n        const ret = wasm.automerge_applyAndReturnPatches(this.__wbg_ptr, object, meta);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @returns {Patch[]}\n     */\n    diffIncremental() {\n        const ret = wasm.automerge_diffIncremental(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    updateDiffCursor() {\n        wasm.automerge_updateDiffCursor(this.__wbg_ptr);\n    }\n    resetDiffCursor() {\n        wasm.automerge_resetDiffCursor(this.__wbg_ptr);\n    }\n    /**\n     * @param {Heads} before\n     * @param {Heads} after\n     * @returns {Patch[]}\n     */\n    diff(before, after) {\n        const ret = wasm.automerge_diff(this.__wbg_ptr, before, after);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Heads} heads\n     */\n    isolate(heads) {\n        const ret = wasm.automerge_isolate(this.__wbg_ptr, heads);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    integrate() {\n        wasm.automerge_integrate(this.__wbg_ptr);\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {number}\n     */\n    length(obj, heads) {\n        const ret = wasm.automerge_length(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return ret[0];\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {Prop} prop\n     */\n    delete(obj, prop) {\n        const ret = wasm.automerge_delete(this.__wbg_ptr, obj, prop);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    save() {\n        const ret = wasm.automerge_save(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    saveIncremental() {\n        const ret = wasm.automerge_saveIncremental(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {Heads} heads\n     * @returns {Uint8Array}\n     */\n    saveSince(heads) {\n        const ret = wasm.automerge_saveSince(this.__wbg_ptr, heads);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    saveNoCompress() {\n        const ret = wasm.automerge_saveNoCompress(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Uint8Array}\n     */\n    saveAndVerify() {\n        const ret = wasm.automerge_saveAndVerify(this.__wbg_ptr);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Uint8Array} data\n     * @returns {number}\n     */\n    loadIncremental(data) {\n        const ret = wasm.automerge_loadIncremental(this.__wbg_ptr, data);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return ret[0];\n    }\n    /**\n     * @param {Change[]} changes\n     */\n    applyChanges(changes) {\n        const ret = wasm.automerge_applyChanges(this.__wbg_ptr, changes);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {Heads} have_deps\n     * @returns {Change[]}\n     */\n    getChanges(have_deps) {\n        const ret = wasm.automerge_getChanges(this.__wbg_ptr, have_deps);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Heads} have_deps\n     * @returns {ChangeMetadata[]}\n     */\n    getChangesMeta(have_deps) {\n        const ret = wasm.automerge_getChangesMeta(this.__wbg_ptr, have_deps);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {Change | null}\n     */\n    getChangeByHash(hash) {\n        const ret = wasm.automerge_getChangeByHash(this.__wbg_ptr, hash);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {ChangeMetadata | null}\n     */\n    getChangeMetaByHash(hash) {\n        const ret = wasm.automerge_getChangeMetaByHash(this.__wbg_ptr, hash);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {DecodedChange | null}\n     */\n    getDecodedChangeByHash(hash) {\n        const ret = wasm.automerge_getDecodedChangeByHash(this.__wbg_ptr, hash);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {Automerge} other\n     * @returns {Change[]}\n     */\n    getChangesAdded(other) {\n        _assertClass(other, Automerge);\n        const ret = wasm.automerge_getChangesAdded(this.__wbg_ptr, other.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Heads}\n     */\n    getHeads() {\n        const ret = wasm.automerge_getHeads(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Actor}\n     */\n    getActorId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.automerge_getActorId(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * @returns {Change | null}\n     */\n    getLastLocalChange() {\n        const ret = wasm.automerge_getLastLocalChange(this.__wbg_ptr);\n        return ret;\n    }\n    dump() {\n        wasm.automerge_dump(this.__wbg_ptr);\n    }\n    /**\n     * @param {Array<any> | null} [heads]\n     * @returns {Array<any>}\n     */\n    getMissingDeps(heads) {\n        const ret = wasm.automerge_getMissingDeps(this.__wbg_ptr, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {SyncState} state\n     * @param {SyncMessage} message\n     */\n    receiveSyncMessage(state, message) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_receiveSyncMessage(this.__wbg_ptr, state.__wbg_ptr, message);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {SyncState} state\n     * @returns {SyncMessage | null}\n     */\n    generateSyncMessage(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_generateSyncMessage(this.__wbg_ptr, state.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {any} meta\n     * @returns {MaterializeValue}\n     */\n    toJS(meta) {\n        const ret = wasm.automerge_toJS(this.__wbg_ptr, meta);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null | undefined} heads\n     * @param {any} meta\n     * @returns {any}\n     */\n    materialize(obj, heads, meta) {\n        const ret = wasm.automerge_materialize(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads), meta);\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {any} position\n     * @param {Array<any> | null | undefined} heads\n     * @param {any} move_cursor\n     * @returns {string}\n     */\n    getCursor(obj, position, heads, move_cursor) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const ret = wasm.automerge_getCursor(this.__wbg_ptr, obj, position, isLikeNone(heads) ? 0 : addToExternrefTable0(heads), move_cursor);\n            var ptr1 = ret[0];\n            var len1 = ret[1];\n            if (ret[3]) {\n                ptr1 = 0; len1 = 0;\n                throw takeFromExternrefTable0(ret[2]);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {any} cursor\n     * @param {Array<any> | null} [heads]\n     * @returns {number}\n     */\n    getCursorPosition(obj, cursor, heads) {\n        const ret = wasm.automerge_getCursorPosition(this.__wbg_ptr, obj, cursor, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return ret[0];\n    }\n    /**\n     * @param {string | null} [message]\n     * @param {number | null} [time]\n     * @returns {Hash}\n     */\n    emptyChange(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_emptyChange(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return ret;\n    }\n    /**\n     * @param {any} obj\n     * @param {any} range\n     * @param {any} name\n     * @param {any} value\n     * @param {any} datatype\n     */\n    mark(obj, range, name, value, datatype) {\n        const ret = wasm.automerge_mark(this.__wbg_ptr, obj, range, name, value, datatype);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {ObjID} obj\n     * @param {MarkRange} range\n     * @param {string} name\n     */\n    unmark(obj, range, name) {\n        const ret = wasm.automerge_unmark(this.__wbg_ptr, obj, range, name);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {any} obj\n     * @param {Array<any> | null} [heads]\n     * @returns {any}\n     */\n    marks(obj, heads) {\n        const ret = wasm.automerge_marks(this.__wbg_ptr, obj, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {any} obj\n     * @param {number} index\n     * @param {Array<any> | null} [heads]\n     * @returns {object}\n     */\n    marksAt(obj, index, heads) {\n        const ret = wasm.automerge_marksAt(this.__wbg_ptr, obj, index, isLikeNone(heads) ? 0 : addToExternrefTable0(heads));\n        if (ret[2]) {\n            throw takeFromExternrefTable0(ret[1]);\n        }\n        return takeFromExternrefTable0(ret[0]);\n    }\n    /**\n     * @param {SyncState} state\n     * @returns {boolean}\n     */\n    hasOurChanges(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_hasOurChanges(this.__wbg_ptr, state.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {Hash[]}\n     */\n    topoHistoryTraversal() {\n        const ret = wasm.automerge_topoHistoryTraversal(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Stats}\n     */\n    stats() {\n        const ret = wasm.automerge_stats(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst SyncStateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_syncstate_free(ptr >>> 0, 1));\n\nexport class SyncState {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SyncState.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncStateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncstate_free(ptr, 0);\n    }\n    /**\n     * @returns {Heads}\n     */\n    get sharedHeads() {\n        const ret = wasm.syncstate_sharedHeads(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {Heads}\n     */\n    get lastSentHeads() {\n        const ret = wasm.syncstate_lastSentHeads(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {Heads} heads\n     */\n    set lastSentHeads(heads) {\n        const ret = wasm.syncstate_set_lastSentHeads(this.__wbg_ptr, heads);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @param {Heads} hashes\n     */\n    set sentHashes(hashes) {\n        const ret = wasm.syncstate_set_sentHashes(this.__wbg_ptr, hashes);\n        if (ret[1]) {\n            throw takeFromExternrefTable0(ret[0]);\n        }\n    }\n    /**\n     * @returns {SyncState}\n     */\n    clone() {\n        const ret = wasm.syncstate_clone(this.__wbg_ptr);\n        return SyncState.__wrap(ret);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {\n        const ret = String(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_apply_eb9e9b97497f91e4 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.apply(arg0, arg1, arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_assign_3627b8559449930a = function(arg0, arg1) {\n        const ret = Object.assign(arg0, arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n        const ret = arg0.buffer;\n        return ret;\n    };\n    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.call(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = arg0.call(arg1, arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_concat_9de968491c4340cf = function(arg0, arg1) {\n        const ret = arg0.concat(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {\n        const ret = arg0.crypto;\n        return ret;\n    };\n    imports.wbg.__wbg_defineProperty_a3ddad9901e2d29e = function(arg0, arg1, arg2) {\n        const ret = Object.defineProperty(arg0, arg1, arg2);\n        return ret;\n    };\n    imports.wbg.__wbg_deleteProperty_96363d4a1d977c97 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.deleteProperty(arg0, arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {\n        const ret = arg0.done;\n        return ret;\n    };\n    imports.wbg.__wbg_entries_3265d4158b33e5dc = function(arg0) {\n        const ret = Object.entries(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_for_4ff07bddd743c5e7 = function(arg0, arg1) {\n        const ret = Symbol.for(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_freeze_ef6d70cf38e8d948 = function(arg0) {\n        const ret = Object.freeze(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_from_2a5d3e218e67aa85 = function(arg0) {\n        const ret = Array.from(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() { return handleError(function (arg0, arg1) {\n        arg0.getRandomValues(arg1);\n    }, arguments) };\n    imports.wbg.__wbg_getTime_46267b1c24877e30 = function(arg0) {\n        const ret = arg0.getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(arg0, arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {\n        const ret = arg0[arg1 >>> 0];\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Date_e9a9be8b9cea7890 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Date;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Object_7f2dcef8f78644a4 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Object;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {\n        const ret = Array.isArray(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {\n        const ret = Symbol.iterator;\n        return ret;\n    };\n    imports.wbg.__wbg_keys_5c77a08ddc2fb8a6 = function(arg0) {\n        const ret = Object.keys(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_d56737991078581b = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbg_log_1ae1e9f741096e91 = function(arg0, arg1) {\n        console.log(arg0, arg1);\n    };\n    imports.wbg.__wbg_log_c222819a41e063d3 = function(arg0) {\n        console.log(arg0);\n    };\n    imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {\n        const ret = arg0.msCrypto;\n        return ret;\n    };\n    imports.wbg.__wbg_new_1ab78df5e132f715 = function(arg0, arg1) {\n        const ret = new RangeError(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_new_31a97dac4f10fab7 = function(arg0) {\n        const ret = new Date(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_new_405e22f390576ce2 = function() {\n        const ret = new Object();\n        return ret;\n    };\n    imports.wbg.__wbg_new_78feb108b6472713 = function() {\n        const ret = new Array();\n        return ret;\n    };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return ret;\n    };\n    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {\n        const ret = new Uint8Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_new_c68d7209be747379 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {\n        const ret = arg0.next;\n        return ret;\n    };\n    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {\n        const ret = arg0.next();\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {\n        const ret = arg0.node;\n        return ret;\n    };\n    imports.wbg.__wbg_ownKeys_3930041068756f1f = function() { return handleError(function (arg0) {\n        const ret = Reflect.ownKeys(arg0);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {\n        const ret = arg0.process;\n        return ret;\n    };\n    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {\n        const ret = arg0.push(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() { return handleError(function (arg0, arg1) {\n        arg0.randomFillSync(arg1);\n    }, arguments) };\n    imports.wbg.__wbg_require_60cc747a6bc5215a = function() { return handleError(function () {\n        const ret = module.require;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {\n        arg0[arg1 >>> 0] = arg2;\n    };\n    imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {\n        arg0[arg1] = arg2;\n    };\n    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(arg0, arg1, arg2);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_slice_972c243648c9fd2e = function(arg0, arg1, arg2) {\n        const ret = arg0.slice(arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {\n        const ret = typeof global === 'undefined' ? null : global;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {\n        const ret = typeof globalThis === 'undefined' ? null : globalThis;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {\n        const ret = typeof self === 'undefined' ? null : self;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {\n        const ret = typeof window === 'undefined' ? null : window;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {\n        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n        return ret;\n    };\n    imports.wbg.__wbg_toString_66ab719c2a98bdf1 = function(arg0) {\n        const ret = arg0.toString();\n        return ret;\n    };\n    imports.wbg.__wbg_unshift_c290010f73f04fb1 = function(arg0, arg1) {\n        const ret = arg0.unshift(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {\n        const ret = arg0.value;\n        return ret;\n    };\n    imports.wbg.__wbg_values_fcb8ba8c0aad8b58 = function(arg0) {\n        const ret = Object.values(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {\n        const ret = arg0.versions;\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return ret;\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = arg0;\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_4;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n    imports.wbg.__wbindgen_is_array = function(arg0) {\n        const ret = Array.isArray(arg0);\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(arg0) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = arg0 === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = arg0;\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(arg0) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = arg0 === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = arg0 == arg1;\n        return ret;\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return ret;\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return ret;\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = arg1;\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new /* @vite-ignore */ URL('automerge_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","import { default as initWasm } from \"./wasm_bindgen_output/web/automerge_wasm.js\";\nimport * as WasmApi from \"./wasm_bindgen_output/web/automerge_wasm.js\";\nlet _initialized = false;\nlet _initializeListeners = [];\nexport function UseApi(api) {\n    for (const k in api) {\n        // eslint-disable-next-line no-extra-semi\n        ;\n        ApiHandler[k] = api[k];\n    }\n    _initialized = true;\n    for (const listener of _initializeListeners) {\n        listener();\n    }\n}\n/* eslint-disable */\nexport const ApiHandler = {\n    create(options) {\n        throw new RangeError(\"Automerge.use() not called\");\n    },\n    load(data, options) {\n        throw new RangeError(\"Automerge.use() not called (load)\");\n    },\n    encodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (encodeChange)\");\n    },\n    decodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (decodeChange)\");\n    },\n    initSyncState() {\n        throw new RangeError(\"Automerge.use() not called (initSyncState)\");\n    },\n    encodeSyncMessage(message) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncMessage)\");\n    },\n    decodeSyncMessage(msg) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncMessage)\");\n    },\n    encodeSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncState)\");\n    },\n    decodeSyncState(data) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncState)\");\n    },\n    exportSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (exportSyncState)\");\n    },\n    importSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (importSyncState)\");\n    },\n};\n/* eslint-enable */\n/**\n * Initialize the wasm module\n *\n * @param wasmBlob - The wasm module as a Uint8Array, Request, Promise<Uint8Array> or string. If this argument is a string then it is assumed to be a URL and the library will attempt to fetch the wasm module from that URL.\n *\n * @remarks\n * If you are using the `/slim` subpath export then this function must be\n * called before any other functions in the library. If you are using any of\n * the other subpath exports then it will have already been called for you.\n */\nexport function initializeWasm(wasmBlob) {\n    return initWasm({ module_or_path: wasmBlob }).then(_ => {\n        UseApi(WasmApi);\n    });\n}\n/**\n * Initialize the wasm module from a base64 encoded string\n *\n * @param wasmBase64 - The bytes of the wasm file as a base64 encoded string\n */\nexport function initializeBase64Wasm(wasmBase64) {\n    return initializeWasm(Uint8Array.from(atob(wasmBase64), c => c.charCodeAt(0)));\n}\n/**\n * A promise which resolves when the web assembly module has been initialized\n * (or immediately if it has already been initialized)\n */\nexport function wasmInitialized() {\n    if (_initialized)\n        return Promise.resolve();\n    return new Promise(resolve => {\n        _initializeListeners.push(resolve);\n    });\n}\n/**\n * Check if the wasm module has been initialized\n *\n * @returns true if the wasm module has been initialized\n */\nexport function isWasmInitialized() {\n    return _initialized;\n}\n","import { CLEAR_CACHE, IS_PROXY, OBJECT_ID, STATE, TRACE } from \"./constants.js\";\nexport function _state(doc, checkroot = true) {\n    if (typeof doc !== \"object\") {\n        throw new RangeError(\"must be the document root\");\n    }\n    const state = Reflect.get(doc, STATE);\n    if (state === undefined ||\n        state == null ||\n        (checkroot && _obj(doc) !== \"_root\")) {\n        throw new RangeError(\"must be the document root\");\n    }\n    return state;\n}\nexport function _clear_cache(doc) {\n    Reflect.set(doc, CLEAR_CACHE, true);\n}\nexport function _trace(doc) {\n    return Reflect.get(doc, TRACE);\n}\nexport function _obj(doc) {\n    if (!(typeof doc === \"object\") || doc === null) {\n        return null;\n    }\n    return Reflect.get(doc, OBJECT_ID);\n}\nexport function _is_proxy(doc) {\n    return !!Reflect.get(doc, IS_PROXY);\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { isImmutableString, rootProxy } from \"./proxies.js\";\nexport { isImmutableString, isCounter } from \"./proxies.js\";\nimport { STATE } from \"./constants.js\";\nimport { Counter, } from \"./types.js\";\nexport { Counter, Int, Uint, Float64, } from \"./types.js\";\nconst _SyncStateSymbol = Symbol(\"_syncstate\");\nimport { ApiHandler, UseApi } from \"./low_level.js\";\nexport { initializeWasm, initializeBase64Wasm, wasmInitialized, isWasmInitialized, } from \"./low_level.js\";\nimport { ImmutableString } from \"./immutable_string.js\";\nexport { ImmutableString } from \"./immutable_string.js\";\nimport { _state, _is_proxy, _clear_cache, _trace, _obj, } from \"./internal_state.js\";\nexport { applyPatch, applyPatches } from \"./apply_patches.js\";\nimport { conflictAt } from \"./conflicts.js\";\n/**\n * Function for use in {@link change} which inserts values into a list at a given index\n * @param list\n * @param index\n * @param values\n */\nexport function insertAt(list, index, ...values) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    //eslint-disable-next-line no-extra-semi\n    ;\n    list.insertAt(index, ...values);\n}\n/**\n * Function for use in {@link change} which deletes values from a list at a given index\n * @param list\n * @param index\n * @param numDelete\n */\nexport function deleteAt(list, index, numDelete) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    //eslint-disable-next-line no-extra-semi\n    ;\n    list.deleteAt(index, numDelete);\n}\n/** @hidden **/\nexport function use(api) {\n    UseApi(api);\n}\n/** @hidden */\nexport function getBackend(doc) {\n    return _state(doc).handle;\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\nexport function getChangesSince(state, heads) {\n    const n = _state(state);\n    return n.handle.getChanges(heads);\n}\nexport function getChangesMetaSince(state, heads) {\n    const n = _state(state);\n    return n.handle.getChangesMeta(heads);\n}\nfunction cursorToIndex(state, value, index) {\n    if (typeof index == \"string\") {\n        if (/^-?[0-9]+@[0-9a-zA-Z]+$|^[se]$/.test(index)) {\n            return state.handle.getCursorPosition(value, index);\n        }\n        else {\n            throw new RangeError(\"index must be a number or cursor\");\n        }\n    }\n    else {\n        return index;\n    }\n}\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nexport function init(_opts) {\n    const opts = importOpts(_opts);\n    const freeze = !!opts.freeze;\n    const patchCallback = opts.patchCallback;\n    const actor = opts.actor;\n    const handle = ApiHandler.create({ actor });\n    handle.enableFreeze(!!opts.freeze);\n    registerDatatypes(handle);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        freeze,\n        patchCallback,\n    });\n    return doc;\n}\n/**\n * Make an immutable view of an automerge document as at `heads`\n *\n * @remarks\n * The document returned from this function cannot be passed to {@link change}.\n * This is because it shares the same underlying memory as `doc`, but it is\n * consequently a very cheap copy.\n *\n * Note that this function will throw an error if any of the hashes in `heads`\n * are not in the document.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to create a view of\n * @param heads - The hashes of the heads to create a view at\n */\nexport function view(doc, heads) {\n    const state = _state(doc);\n    const handle = state.handle;\n    return state.handle.materialize(\"/\", heads, Object.assign(Object.assign({}, state), { handle,\n        heads }));\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nexport function clone(doc, _opts) {\n    const state = _state(doc);\n    const heads = state.heads;\n    const opts = importOpts(_opts);\n    const handle = state.handle.fork(opts.actor, heads);\n    handle.updateDiffCursor();\n    // `change` uses the presence of state.heads to determine if we are in a view\n    // set it to undefined to indicate that this is a full fat document\n    const { heads: _oldHeads } = state, stateSansHeads = __rest(state, [\"heads\"]);\n    stateSansHeads.patchCallback = opts.patchCallback;\n    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));\n}\n/** Explicity free the memory backing a document. Note that this is note\n * necessary in environments which support\n * [`FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)\n */\nexport function free(doc) {\n    return _state(doc).handle.free();\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nexport function from(initialState, _opts) {\n    return _change(init(_opts), \"from\", {}, d => Object.assign(d, initialState))\n        .newDoc;\n}\n/**\n * Update the contents of an automerge document\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.\n *\n * @example A simple change\n * ```\n * let doc1 = automerge.init()\n * doc1 = automerge.change(doc1, d => {\n *     d.key = \"value\"\n * })\n * assert.equal(doc1.key, \"value\")\n * ```\n *\n * @example A change with a message\n *\n * ```\n * doc1 = automerge.change(doc1, \"add another value\", d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example A change with a message and a timestamp\n *\n * ```\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200}, d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example responding to a patch callback\n * ```\n * let patchedPath\n * let patchCallback = patch => {\n *    patchedPath = patch.path\n * }\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200, patchCallback}, d => {\n *     d.key2 = \"value2\"\n * })\n * assert.equal(patchedPath, [\"key2\"])\n * ```\n */\nexport function change(doc, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"change\", {}, options).newDoc;\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"change\", options, callback).newDoc;\n    }\n    else {\n        throw RangeError(\"Invalid args for change\");\n    }\n}\n/**\n * Make a change to the document as it was at a particular point in history\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param scope - The heads representing the point in history to make the change\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * @remarks\n * This function is similar to {@link change} but allows you to make changes to\n * the document as if it were at a particular point in time. To understand this\n * imagine a document created with the following history:\n *\n * ```ts\n * let doc = automerge.from({..})\n * doc = automerge.change(doc, () => {...})\n *\n * const heads = automerge.getHeads(doc)\n *\n * // fork the document make a change\n * let fork = automerge.fork(doc)\n * fork = automerge.change(fork, () => {...})\n * const headsOnFork = automerge.getHeads(fork)\n *\n * // make a change on the original doc\n * doc = automerge.change(doc, () => {...})\n * const headsOnOriginal = automerge.getHeads(doc)\n *\n * // now merge the changes back to the original document\n * doc = automerge.merge(doc, fork)\n *\n * // The heads of the document will now be (headsOnFork, headsOnOriginal)\n * ```\n *\n * {@link ChangeAt} produces an equivalent history, but without having to\n * create a fork of the document. In particular the `newHeads` field of the\n * returned {@link ChangeAtResult} will be the same as `headsOnFork`.\n *\n * Why would you want this? It's typically used in conjunction with {@link diff}\n * to reconcile state which is managed concurrently with the document. For\n * example, if you have a text editor component which the user is modifying\n * and you can't send the changes to the document synchronously you might follow\n * a workflow like this:\n *\n * * On initialization save the current heads of the document in the text editor state\n * * Every time the user makes a change record the change in the text editor state\n *\n * Now from time to time reconcile the editor state and the document\n * * Load the last saved heads from the text editor state, call them `oldHeads`\n * * Apply all the unreconciled changes to the document using `changeAt(doc, oldHeads, ...)`\n * * Get the diff from the resulting document to the current document using {@link diff}\n *   passing the {@link ChangeAtResult.newHeads} as the `before` argument and the\n *   heads of the entire document as the `after` argument.\n * * Apply the diff to the text editor state\n * * Save the current heads of the document in the text editor state\n */\nexport function changeAt(doc, scope, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"changeAt\", {}, options, scope);\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"changeAt\", options, callback, scope);\n    }\n    else {\n        throw RangeError(\"Invalid args for changeAt\");\n    }\n}\nfunction progressDocument(doc, source, heads, callback) {\n    if (heads == null) {\n        return doc;\n    }\n    const state = _state(doc);\n    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });\n    const { value: nextDoc, patches } = state.handle.applyAndReturnPatches(doc, nextState);\n    if (patches.length > 0) {\n        if (callback != null) {\n            callback(patches, { before: doc, after: nextDoc, source });\n        }\n        const newState = _state(nextDoc);\n        newState.mostRecentPatch = {\n            before: _state(doc).heads,\n            after: newState.handle.getHeads(),\n            patches,\n        };\n    }\n    state.heads = heads;\n    return nextDoc;\n}\nfunction _change(doc, source, options, callback, scope) {\n    if (typeof callback !== \"function\") {\n        throw new RangeError(\"invalid change function\");\n    }\n    const state = _state(doc);\n    if (doc === undefined || state === undefined) {\n        throw new RangeError(\"must be the document root\");\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    let heads = state.handle.getHeads();\n    if (scope && headsEqual(scope, heads)) {\n        scope = undefined;\n    }\n    if (scope) {\n        state.handle.isolate(scope);\n        heads = scope;\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    try {\n        state.heads = heads;\n        const root = rootProxy(state.handle);\n        callback(root);\n        if (state.handle.pendingOps() === 0) {\n            state.heads = undefined;\n            if (scope) {\n                state.handle.integrate();\n            }\n            return {\n                newDoc: doc,\n                newHeads: null,\n            };\n        }\n        else {\n            const newHead = state.handle.commit(options.message, options.time);\n            state.handle.integrate();\n            return {\n                newDoc: progressDocument(doc, source, heads, options.patchCallback || state.patchCallback),\n                newHeads: newHead != null ? [newHead] : null,\n            };\n        }\n    }\n    catch (e) {\n        state.heads = undefined;\n        state.handle.rollback();\n        throw e;\n    }\n}\n/**\n * Make a change to a document which does not modify the document\n *\n * @param doc - The doc to add the empty change to\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n *\n * Why would you want to do this? One reason might be that you have merged\n * changes from some other peers and you want to generate a change which\n * depends on those merged changes so that you can sign the new change with all\n * of the merged changes as part of the new change.\n */\nexport function emptyChange(doc, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    if (typeof options === \"string\") {\n        options = { message: options };\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.emptyChange(options.message, options.time);\n    return progressDocument(doc, \"emptyChange\", heads);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nexport function load(data, _opts) {\n    const opts = importOpts(_opts);\n    if (opts.patchCallback) {\n        return loadIncremental(init(opts), data);\n    }\n    const actor = opts.actor;\n    const patchCallback = opts.patchCallback;\n    const unchecked = opts.unchecked || false;\n    const allowMissingDeps = opts.allowMissingChanges || false;\n    const convertImmutableStringsToText = opts.convertImmutableStringsToText || false;\n    const handle = ApiHandler.load(data, {\n        actor,\n        unchecked,\n        allowMissingDeps,\n        convertImmutableStringsToText,\n    });\n    handle.enableFreeze(!!opts.freeze);\n    registerDatatypes(handle);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        patchCallback,\n    });\n    return doc;\n}\n/**\n * Load changes produced by {@link saveIncremental}, or partial changes\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressedchanges\n * @param opts  - an {@link ApplyOptions}\n *\n * This function is useful when staying up to date with a connected peer.\n * Perhaps the other end sent you a full compresed document which you loaded\n * with {@link load} and they're sending you the result of\n * {@link getLastLocalChange} every time they make a change.\n *\n * Note that this function will succesfully load the results of {@link save} as\n * well as {@link getLastLocalChange} or any other incremental change.\n */\nexport function loadIncremental(doc, data, opts) {\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.loadIncremental(data);\n    return progressDocument(doc, \"loadIncremental\", heads, opts.patchCallback || state.patchCallback);\n}\n/**\n * Create binary save data to be appended to a save file or fed into {@link loadIncremental}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n *\n * This function is useful for incrementally saving state.  The data can be appended to a\n * automerge save file, or passed to a document replicating its state.\n *\n */\nexport function saveIncremental(doc) {\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    return state.handle.saveIncremental();\n}\n/**\n * Export the contents of a document to a compressed format\n *\n * @param doc - The doc to save\n *\n * The returned bytes can be passed to {@link load} or {@link loadIncremental}\n */\nexport function save(doc) {\n    return _state(doc).handle.save();\n}\n/**\n * Merge `remote` into `local`\n * @typeParam T - The type of values contained in each document\n * @param local - The document to merge changes into\n * @param remote - The document to merge changes from\n *\n * @returns - The merged document\n *\n * Often when you are merging documents you will also need to clone them. Both\n * arguments to `merge` are frozen after the call so you can no longer call\n * mutating methods (such as {@link change}) on them. The symtom of this will be\n * an error which says \"Attempting to change an out of date document\". To\n * overcome this call {@link clone} on the argument before passing it to {@link\n * merge}.\n */\nexport function merge(local, remote) {\n    const localState = _state(local);\n    if (localState.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(local));\n    }\n    const heads = localState.handle.getHeads();\n    const remoteState = _state(remote);\n    const changes = localState.handle.getChangesAdded(remoteState.handle);\n    localState.handle.applyChanges(changes);\n    return progressDocument(local, \"merge\", heads, localState.patchCallback);\n}\n/**\n * Get the actor ID associated with the document\n */\nexport function getActorId(doc) {\n    const state = _state(doc);\n    return state.handle.getActorId();\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n */\nexport function getConflicts(doc, prop) {\n    const state = _state(doc, false);\n    const objectId = _obj(doc);\n    if (objectId != null) {\n        const withinChangeCallback = _is_proxy(doc);\n        return conflictAt(state.handle, objectId, prop, withinChangeCallback);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Get the binary representation of the last change which was made to this doc\n *\n * This is most useful when staying in sync with other peers, every time you\n * make a change locally via {@link change} you immediately call {@link\n * getLastLocalChange} and send the result over the network to other peers.\n */\nexport function getLastLocalChange(doc) {\n    const state = _state(doc);\n    return state.handle.getLastLocalChange() || undefined;\n}\n/**\n * Return the object ID of an arbitrary javascript value\n *\n * This is useful to determine if something is actually an automerge document,\n * if `doc` is not an automerge document this will return null.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getObjectId(doc, prop) {\n    if (prop) {\n        const state = _state(doc, false);\n        const objectId = _obj(doc);\n        if (!state || !objectId) {\n            return null;\n        }\n        return state.handle.get(objectId, prop);\n    }\n    else {\n        return _obj(doc);\n    }\n}\n/**\n * Get the changes which are in `newState` but not in `oldState`. The returned\n * changes can be loaded in `oldState` via {@link applyChanges}.\n *\n * Note that this will crash if there are changes in `oldState` which are not in `newState`.\n */\nexport function getChanges(oldState, newState) {\n    const n = _state(newState);\n    return n.handle.getChanges(getHeads(oldState));\n}\n/**\n * Get all the changes in a document\n *\n * This is different to {@link save} because the output is an array of changes\n * which can be individually applied via {@link applyChanges}`\n *\n */\nexport function getAllChanges(doc) {\n    const state = _state(doc);\n    return state.handle.getChanges([]);\n}\n/**\n * Apply changes received from another document\n *\n * `doc` will be updated to reflect the `changes`. If there are changes which\n * we do not have dependencies for yet those will be stored in the document and\n * applied when the depended on changes arrive.\n *\n * You can use the {@link ApplyOptions} to pass a patchcallback which will be\n * informed of any changes which occur as a result of applying the changes\n *\n */\nexport function applyChanges(doc, changes, opts) {\n    const state = _state(doc);\n    if (!opts) {\n        opts = {};\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.applyChanges(changes);\n    state.heads = heads;\n    return [\n        progressDocument(doc, \"applyChanges\", heads, opts.patchCallback || state.patchCallback),\n    ];\n}\n/** @hidden */\nexport function getHistory(doc) {\n    const history = getAllChanges(doc);\n    return history.map((change, index) => ({\n        get change() {\n            return decodeChange(change);\n        },\n        get snapshot() {\n            const [state] = applyChanges(init(), history.slice(0, index + 1));\n            return state;\n        },\n    }));\n}\n/**\n * Create a set of patches representing the change from one set of heads to another\n *\n * If either of the heads are missing from the document the returned set of patches will be empty\n */\nexport function diff(doc, before, after) {\n    checkHeads(before, \"before\");\n    checkHeads(after, \"after\");\n    const state = _state(doc);\n    if (state.mostRecentPatch &&\n        equals(state.mostRecentPatch.before, before) &&\n        equals(state.mostRecentPatch.after, after)) {\n        return state.mostRecentPatch.patches;\n    }\n    return state.handle.diff(before, after);\n}\nfunction headsEqual(heads1, heads2) {\n    if (heads1.length !== heads2.length) {\n        return false;\n    }\n    for (let i = 0; i < heads1.length; i++) {\n        if (heads1[i] !== heads2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction checkHeads(heads, fieldname) {\n    if (!Array.isArray(heads)) {\n        throw new Error(`${fieldname} must be an array`);\n    }\n}\n/** @hidden */\n// FIXME : no tests\n// FIXME can we just use deep equals now?\nexport function equals(val1, val2) {\n    if (!isObject(val1) || !isObject(val2))\n        return val1 === val2;\n    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();\n    if (keys1.length !== keys2.length)\n        return false;\n    for (let i = 0; i < keys1.length; i++) {\n        if (keys1[i] !== keys2[i])\n            return false;\n        if (!equals(val1[keys1[i]], val2[keys2[i]]))\n            return false;\n    }\n    return true;\n}\n/**\n * encode a {@link SyncState} into binary to send over the network\n *\n * @group sync\n * */\nexport function encodeSyncState(state) {\n    const sync = ApiHandler.importSyncState(state);\n    const result = ApiHandler.encodeSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Decode some binary data into a {@link SyncState}\n *\n * @group sync\n */\nexport function decodeSyncState(state) {\n    const sync = ApiHandler.decodeSyncState(state);\n    const result = ApiHandler.exportSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Generate a sync message to send to the peer represented by `inState`\n * @param doc - The doc to generate messages about\n * @param inState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns An array of `[newSyncState, syncMessage | null]` where\n * `newSyncState` should replace `inState` and `syncMessage` should be sent to\n * the peer if it is not null. If `syncMessage` is null then we are up to date.\n */\nexport function generateSyncMessage(doc, inState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(inState);\n    const message = state.handle.generateSyncMessage(syncState);\n    const outState = ApiHandler.exportSyncState(syncState);\n    return [outState, message];\n}\n/**\n * Update a document and our sync state on receiving a sync message\n *\n * @group sync\n *\n * @param doc     - The doc the sync message is about\n * @param inState - The {@link SyncState} for the peer we are communicating with\n * @param message - The message which was received\n * @param opts    - Any {@link ApplyOption}s, used for passing a\n *                  {@link PatchCallback} which will be informed of any changes\n *                  in `doc` which occur because of the received sync message.\n *\n * @returns An array of `[newDoc, newSyncState, null]` where\n * `newDoc` is the updated state of `doc`, `newSyncState` should replace\n * `inState`.\n *\n * @remarks Note that this function has three return values for legacy reasons.\n * The third value used to be a sync message to send back but this is now\n * always null and you should instead call `generateSyncMessage` after calling\n * `receiveSyncMessage` to see if there are new messages to send.\n */\nexport function receiveSyncMessage(doc, inState, message, opts) {\n    const syncState = ApiHandler.importSyncState(inState);\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.receiveSyncMessage(syncState, message);\n    const outSyncState = ApiHandler.exportSyncState(syncState);\n    return [\n        progressDocument(doc, \"receiveSyncMessage\", heads, opts.patchCallback || state.patchCallback),\n        outSyncState,\n        null,\n    ];\n}\n/**\n * Check whether the replica represented by `remoteState` has all our changes\n *\n * @param doc - The doc to check whether the remote has changes for\n * @param remoteState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns true if the remote has all of our changes\n */\nexport function hasOurChanges(doc, remoteState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(remoteState);\n    return state.handle.hasOurChanges(syncState);\n}\n/**\n * Create a new, blank {@link SyncState}\n *\n * When communicating with a peer for the first time use this to generate a new\n * {@link SyncState} for them\n *\n * @group sync\n */\nexport function initSyncState() {\n    return ApiHandler.exportSyncState(ApiHandler.initSyncState());\n}\n/** @hidden */\nexport function encodeChange(change) {\n    return ApiHandler.encodeChange(change);\n}\n/** @hidden */\nexport function decodeChange(data) {\n    return ApiHandler.decodeChange(data);\n}\n/** @hidden */\nexport function encodeSyncMessage(message) {\n    return ApiHandler.encodeSyncMessage(message);\n}\n/** @hidden */\nexport function decodeSyncMessage(message) {\n    return ApiHandler.decodeSyncMessage(message);\n}\n/**\n * Get any changes in `doc` which are not dependencies of `heads`\n */\nexport function getMissingDeps(doc, heads) {\n    const state = _state(doc);\n    return state.handle.getMissingDeps(heads);\n}\n/**\n * Get the hashes of the heads of this document\n */\nexport function getHeads(doc) {\n    const state = _state(doc);\n    return state.heads || state.handle.getHeads();\n}\n/** @hidden */\nexport function dump(doc) {\n    const state = _state(doc);\n    state.handle.dump();\n}\n/** @hidden */\nexport function toJS(doc) {\n    const state = _state(doc);\n    const enabled = state.handle.enableFreeze(false);\n    const result = state.handle.materialize(\"/\", state.heads);\n    state.handle.enableFreeze(enabled);\n    return result;\n}\nexport function isAutomerge(doc) {\n    if (typeof doc == \"object\" && doc !== null) {\n        return getObjectId(doc) === \"_root\" && !!Reflect.get(doc, STATE);\n    }\n    else {\n        return false;\n    }\n}\nfunction isObject(obj) {\n    return typeof obj === \"object\" && obj !== null;\n}\nexport function saveSince(doc, heads) {\n    const state = _state(doc);\n    const result = state.handle.saveSince(heads);\n    return result;\n}\n/**\n * Returns true if the document has all of the given heads somewhere in its history\n */\nexport function hasHeads(doc, heads) {\n    const state = _state(doc);\n    for (const hash of heads) {\n        if (!state.handle.getChangeByHash(hash)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction registerDatatypes(handle) {\n    handle.registerDatatype(\"counter\", (n) => new Counter(n), n => {\n        if (n instanceof Counter) {\n            return n.value;\n        }\n    });\n    handle.registerDatatype(\"str\", (n) => {\n        return new ImmutableString(n);\n    }, s => {\n        if (isImmutableString(s)) {\n            return s.val;\n        }\n    });\n}\n/**\n * @hidden\n */\nexport function topoHistoryTraversal(doc) {\n    const state = _state(doc);\n    return state.handle.topoHistoryTraversal();\n}\n/**\n * Decode a change hash into the details of this change\n *\n * This should be considered a semi-stable API. We try not to change the\n * encoding in backwards incompatible ways but we won't bump a major version if\n * we do have to change it\n */\nexport function inspectChange(doc, changeHash) {\n    const state = _state(doc);\n    return state.handle.getDecodedChangeByHash(changeHash);\n}\n/**\n * Return some internal statistics about the document\n */\nexport function stats(doc) {\n    const state = _state(doc);\n    return state.handle.stats();\n}\n/**\n * Modify a string\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to modify\n * @param path - The path to the string to modify\n * @param index - The position (as a {@link Cursor} or index) to edit.\n *   If a cursor is used then the edit happens such that the cursor will\n *   now point to the end of the newText, so you can continue to reuse\n *   the same cursor for multiple calls to splice.\n * @param del - The number of code units to delete, a positive number\n *   deletes N characters after the cursor, a negative number deletes\n *   N characters before the cursor.\n * @param newText - The string to insert (if any).\n */\nexport function splice(doc, path, index, del, newText) {\n    const objPath = absoluteObjPath(doc, path, \"splice\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        return state.handle.splice(objPath, index, del, newText);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Update the value of a string\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to modify\n * @param path - The path to the string to modify\n * @param newText - The new text to update the value to\n *\n * @remarks\n * This will calculate a diff between the current value and the new value and\n * then convert that diff into calls to {@link splice}. This will produce results\n * which don't merge as well as directly capturing the user input actions, but\n * sometimes it's not possible to capture user input and this is the best you\n * can do.\n *\n * This is an experimental API and may change in the future.\n *\n * @beta\n */\nexport function updateText(doc, path, newText) {\n    const objPath = absoluteObjPath(doc, path, \"updateText\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    try {\n        return state.handle.updateText(objPath, newText);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateText: ${e}`);\n    }\n}\n/**\n * Return the text + block markers at a given path\n *\n * @remarks\n * Rich text in automerge is represented as a sequence of characters with block\n * markers appearing inline with the text, and inline formatting spans overlaid\n * on the whole sequence. Block markers are normal automerge maps, but they are\n * only visible via either the {@link block} function or the {@link spans}\n * function. This function returns the current state of the spans\n */\nexport function spans(doc, path) {\n    const state = _state(doc, false);\n    const objPath = absoluteObjPath(doc, path, \"spans\");\n    try {\n        return state.handle.spans(objPath, state.heads);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Get the block marker at the given index\n */\nexport function block(doc, path, index) {\n    const objPath = absoluteObjPath(doc, path, \"splitBlock\");\n    const state = _state(doc, false);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        return state.handle.getBlock(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot get block: ${e}`);\n    }\n}\n/**\n * Insert a new block marker at the given index\n */\nexport function splitBlock(doc, path, index, block) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"splitBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.splitBlock(objPath, index, block);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Delete the block marker at the given index\n */\nexport function joinBlock(doc, path, index) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"joinBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.joinBlock(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot joinBlock: ${e}`);\n    }\n}\n/**\n * Update the block marker at the given index\n */\nexport function updateBlock(doc, path, index, block) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"updateBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.updateBlock(objPath, index, block);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateBlock: ${e}`);\n    }\n}\n/**\n * Update the spans at the given path\n *\n * @remarks\n * Like {@link updateText} this will diff `newSpans` against the current state\n * of the text at `path` and perform a reasonably minimal number of operations\n * required to update the spans to the new state.\n */\nexport function updateSpans(doc, path, newSpans) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"updateSpans\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    try {\n        state.handle.updateSpans(objPath, newSpans);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateBlock: ${e}`);\n    }\n}\n/**\n * Returns a cursor for the given position in a string.\n *\n * @remarks\n * A cursor represents a relative position, \"before character X\",\n * rather than an absolute position. As the document is edited, the\n * cursor remains stable relative to its context, just as you'd expect\n * from a cursor in a concurrent text editor.\n *\n * The string representation is shareable, and so you can use this both\n * to edit the document yourself (using {@link splice}) or to share multiple\n * collaborator's current cursor positions over the network.\n *\n * The cursor's `position` can be an index in the string, `'start'` or `'end'`.\n * - `'start'` ensures this cursor always resolves to `0`\n * - `'end'` ensures this cursor always resolves to `string.length`\n *\n * Start cursors can be created by passing any negative number in `position`.\n *\n * End cursors can be created by passing a number `>= string.length` in `position`.\n *\n * `move` determines the position the cursor resolves to if the character at\n * `index` is removed:\n * - `'after'` causes the cursor to resolve towards `string.length`\n * - `'before'` causes the cursor to resolve towards `0`\n *\n * `move` is `'after'` by default.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document\n * @param path - The path to the string\n * @param position - The position of the cursor, either an index, `'start'` or `'end'`\n * @param move - The direction the cursor should resolve to, defaults to 'after'\n */\nexport function getCursor(doc, path, position, move) {\n    const objPath = absoluteObjPath(doc, path, \"getCursor\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.getCursor(objPath, position, state.heads, move);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot getCursor: ${e}`);\n    }\n}\n/**\n * Returns the current index of the cursor.\n *\n * @typeParam T - The type of the value contained in the document\n *\n * @param doc - The document\n * @param path - The path to the string\n * @param index - The cursor\n */\nexport function getCursorPosition(doc, path, cursor) {\n    const objPath = absoluteObjPath(doc, path, \"getCursorPosition\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.getCursorPosition(objPath, cursor, state.heads);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot getCursorPosition: ${e}`);\n    }\n}\nexport function mark(doc, path, range, name, value) {\n    const objPath = absoluteObjPath(doc, path, \"mark\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    try {\n        return state.handle.mark(objPath, range, name, value);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot mark: ${e}`);\n    }\n}\nexport function unmark(doc, path, range, name) {\n    const objPath = absoluteObjPath(doc, path, \"unmark\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    try {\n        return state.handle.unmark(objPath, range, name);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot unmark: ${e}`);\n    }\n}\nexport function marks(doc, path) {\n    const objPath = absoluteObjPath(doc, path, \"marks\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.marks(objPath);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot call marks(): ${e}`);\n    }\n}\nexport function marksAt(doc, path, index) {\n    const objPath = absoluteObjPath(doc, path, \"marksAt\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.marksAt(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot call marksAt(): ${e}`);\n    }\n}\nfunction absoluteObjPath(doc, path, functionName) {\n    path = path.slice();\n    const objectId = _obj(doc);\n    if (!objectId) {\n        throw new RangeError(`invalid object for ${functionName}`);\n    }\n    path.unshift(objectId);\n    return path.join(\"/\");\n}\n/**\n * @deprecated This method has been renamed to {@link isImmutableString}\n */\nexport const isRawString = isImmutableString;\n/**\n * @deprecated This type has been renamed to {@link ImmutableString}\n */\nexport const RawString = ImmutableString;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n}\nfunction getDevTools() {\n  const w = getGlobal();\n  if (w.__xstate__) {\n    return w.__xstate__;\n  }\n  return undefined;\n}\nfunction registerService(service) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n}\nconst devToolsAdapter = service => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n  const devTools = getDevTools();\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n\nexport { devToolsAdapter, getGlobal, registerService };\n","import { devToolsAdapter } from '../dev/dist/xstate-dev.esm.js';\n\nclass Mailbox {\n  constructor(_process) {\n    this._process = _process;\n    this._active = false;\n    this._current = null;\n    this._last = null;\n  }\n  start() {\n    this._active = true;\n    this.flush();\n  }\n  clear() {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n  enqueue(event) {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n    if (this._current) {\n      this._last.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n    this._current = enqueued;\n    this._last = enqueued;\n    if (this._active) {\n      this.flush();\n    }\n  }\n  flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n\nconst STATE_DELIMITER = '.';\nconst TARGETLESS_KEY = '';\nconst NULL_EVENT = '';\nconst STATE_IDENTIFIER = '#';\nconst WILDCARD = '*';\nconst XSTATE_INIT = 'xstate.init';\nconst XSTATE_ERROR = 'xstate.error';\nconst XSTATE_STOP = 'xstate.stop';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nfunction createAfterEvent(delayRef, id) {\n  return {\n    type: `xstate.after.${delayRef}.${id}`\n  };\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nfunction createDoneStateEvent(id, output) {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nfunction createDoneActorEvent(invokeId, output) {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\nfunction createErrorActorEvent(id, error) {\n  return {\n    type: `xstate.error.actor.${id}`,\n    error,\n    actorId: id\n  };\n}\nfunction createInitEvent(input) {\n  return {\n    type: XSTATE_INIT,\n    input\n  };\n}\n\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nfunction reportUnhandledError(err) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n\nconst symbolObservable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();\n\nfunction matchesState(parentStateId, childStateId) {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n  return Object.keys(parentStateValue).every(key => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n    return matchesState(parentStateValue[key], childStateValue[key]);\n  });\n}\nfunction toStatePath(stateId) {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n  const result = [];\n  let segment = '';\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n  result.push(segment);\n  return result;\n}\nfunction toStateValue(stateValue) {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n  if (typeof stateValue !== 'string') {\n    return stateValue;\n  }\n  const statePath = toStatePath(stateValue);\n  return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n  const value = {};\n  let marker = value;\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n  return value;\n}\nfunction mapValues(collection, iteratee) {\n  const result = {};\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n  return result;\n}\nfunction toArrayStrict(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\nfunction toArray(value) {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n  if (typeof mapper === 'function') {\n    return mapper({\n      context,\n      event,\n      self\n    });\n  }\n  return mapper;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n  return event.type.startsWith('xstate.error.actor');\n}\nfunction toTransitionConfigArray(configLike) {\n  return toArrayStrict(configLike).map(transitionLike => {\n    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {\n      return {\n        target: transitionLike\n      };\n    }\n    return transitionLike;\n  });\n}\nfunction normalizeTarget(target) {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n  };\n}\nfunction createInvokeId(stateNodeId, index) {\n  return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke;\n  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n  return [...new Set([...snapshot._nodes.flatMap(sn => sn.ownEvents)])];\n}\n\nfunction createScheduledEventId(actorRef, id) {\n  return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n  const children = new Map();\n  const keyedActors = new Map();\n  const reverseKeyedActors = new WeakMap();\n  const inspectionObservers = new Set();\n  const timerMap = {};\n  const {\n    clock,\n    logger\n  } = options;\n  const scheduler = {\n    schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2)) => {\n      const scheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n        system._relay(source, target, event);\n      }, delay);\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: actorRef => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = event => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(observer => observer.next?.(resolvedInspectionEvent));\n  };\n  const system = {\n    _snapshot: {\n      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: actorRef => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: systemId => {\n      return keyedActors.get(systemId);\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(`Actor with system ID '${systemId}' already exists.`);\n      }\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: observerOrFn => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: {\n          ...system._snapshot._scheduledEvents\n        }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const {\n          source,\n          target,\n          event,\n          delay,\n          id\n        } = scheduledEvents[scheduledId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n  return system;\n}\n\n// those are needed to make JSDoc `@link` work properly\n\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/function (ProcessingStatus) {\n  ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n  ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n  ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n  return ProcessingStatus;\n}({});\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: id => {\n      return clearTimeout(id);\n    }\n  },\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nclass Actor {\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(logic, options) {\n    this.logic = logic;\n    /** The current internal state of the actor. */\n    this._snapshot = void 0;\n    /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */\n    this.clock = void 0;\n    this.options = void 0;\n    /** The unique identifier for this actor relative to its parent. */\n    this.id = void 0;\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this.observers = new Set();\n    this.eventListeners = new Map();\n    this.logger = void 0;\n    /** @internal */\n    this._processingStatus = ProcessingStatus.NotStarted;\n    // Actor Ref\n    this._parent = void 0;\n    /** @internal */\n    this._syncSnapshot = void 0;\n    this.ref = void 0;\n    // TODO: add typings for system\n    this._actorScope = void 0;\n    this._systemId = void 0;\n    /** The globally unique process ID for this invocation. */\n    this.sessionId = void 0;\n    /** The system to which this actor belongs. */\n    this.system = void 0;\n    this._doneEvent = void 0;\n    this.src = void 0;\n    // array of functions to defer\n    this._deferred = [];\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n    const {\n      clock,\n      logger,\n      parent,\n      syncSnapshot,\n      id,\n      systemId,\n      inspect\n    } = resolvedOptions;\n    this.system = parent ? parent.system : createSystem(this, {\n      clock,\n      logger\n    });\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: fn => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: child => {\n        if (child._parent !== this) {\n          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n        }\n        child._stop();\n      },\n      emit: emittedEvent => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [...(listeners ? listeners.values() : []), ...(wildcardListener ? wildcardListener.values() : [])];\n        for (const handler of allListeners) {\n          handler(emittedEvent);\n        }\n      },\n      actionExecutor: action => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n    this._initState(options?.snapshot ?? options?.state);\n    if (systemId && this._snapshot.status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n  _initState(persistedState) {\n    try {\n      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      };\n    }\n  }\n  update(snapshot, event) {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn;\n    while (deferredFn = this._deferred.shift()) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...snapshot,\n          status: 'error',\n          error: err\n        };\n      }\n    }\n    switch (this._snapshot.status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n        break;\n      case 'error':\n        this._error(this._snapshot.error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n\n  subscribe(nextListenerOrObserver, errorListener, completeListener) {\n    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch (this._snapshot.status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error':\n          {\n            const err = this._snapshot.error;\n            if (!observer.error) {\n              reportUnhandledError(err);\n            } else {\n              try {\n                observer.error(err);\n              } catch (err) {\n                reportUnhandledError(err);\n              }\n            }\n            break;\n          }\n      }\n    }\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n  on(type, handler) {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  start() {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: snapshot => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n    const status = this._snapshot.status;\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(this._snapshot, initEvent);\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error(this._snapshot.error);\n        return this;\n    }\n    if (!this._parent) {\n      this.system.start();\n    }\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...this._snapshot,\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent);\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n    this.mailbox.start();\n    return this;\n  }\n  _process(event) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = {\n        err\n      };\n    }\n    if (caughtError) {\n      const {\n        err\n      } = caughtError;\n      this._snapshot = {\n        ...this._snapshot,\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n  _stop() {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({\n      type: XSTATE_STOP\n    });\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  stop() {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  _complete() {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  _reportError(err) {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  _error(err) {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  _stopProcedure() {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n    return this;\n  }\n\n  /** @internal */\n  _send(event) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  send(event) {\n    this.system._relay(undefined, this, event);\n  }\n  attachDevTools() {\n    const {\n      devTools\n    } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter = typeof devTools === 'function' ? devTools : devToolsAdapter;\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n\n  getPersistedSnapshot(options) {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n  [symbolObservable]() {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  getSnapshot() {\n    return this._snapshot;\n  }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nfunction createActor(logic, ...[options]) {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nconst interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\n\nfunction resolveCancel(_, snapshot, actionArgs, actionParams, {\n  sendId\n}) {\n  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, {\n    sendId: resolvedSendId\n  }, undefined];\n}\nfunction executeCancel(actorScope, params) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nfunction cancel(sendId) {\n  function cancel(_args, _params) {\n  }\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n  return cancel;\n}\n\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {\n  id,\n  systemId,\n  src,\n  input,\n  syncSnapshot\n}) {\n  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot.machine, src) : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef;\n  let resolvedInput = undefined;\n  if (logic) {\n    resolvedInput = typeof input === 'function' ? input({\n      context: snapshot.context,\n      event: actionArgs.event,\n      self: actorScope.self\n    }) : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children: {\n      ...snapshot.children,\n      [resolvedId]: actorRef\n    }\n  }), {\n    id,\n    systemId,\n    actorRef,\n    src,\n    input: resolvedInput\n  }, undefined];\n}\nfunction executeSpawn(actorScope, {\n  actorRef\n}) {\n  if (!actorRef) {\n    return;\n  }\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\nfunction spawnChild(...[src, {\n  id,\n  systemId,\n  input,\n  syncSnapshot = false\n} = {}]) {\n  function spawnChild(_args, _params) {\n  }\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n  return spawnChild;\n}\n\nfunction resolveStop(_, snapshot, args, actionParams, {\n  actorRef\n}) {\n  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef = typeof actorRefOrString === 'string' ? snapshot.children[actorRefOrString] : actorRefOrString;\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = {\n      ...children\n    };\n    delete children[resolvedActorRef.id];\n  }\n  return [cloneMachineSnapshot(snapshot, {\n    children\n  }), resolvedActorRef, undefined];\n}\nfunction executeStop(actorScope, actorRef) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  actorScope.system._unregister(actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nfunction stopChild(actorRef) {\n  function stop(_args, _params) {\n  }\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nconst stop = stopChild;\n\nfunction checkStateIn(snapshot, _, {\n  stateValue\n}) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some(sn => sn === target);\n  }\n  return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n  function stateIn() {\n    return false;\n  }\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n  return stateIn;\n}\nfunction checkNot(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nfunction not(guard) {\n  function not(_args, _params) {\n    return false;\n  }\n  not.check = checkNot;\n  not.guards = [guard];\n  return not;\n}\nfunction checkAnd(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.every(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction and(guards) {\n  function and(_args, _params) {\n    return false;\n  }\n  and.check = checkAnd;\n  and.guards = guards;\n  return and;\n}\nfunction checkOr(snapshot, {\n  context,\n  event\n}, {\n  guards\n}) {\n  return guards.some(guard => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nfunction or(guards) {\n  function or(_args, _params) {\n    return false;\n  }\n  or.check = checkOr;\n  or.guards = guards;\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n  const {\n    machine\n  } = snapshot;\n  const isInline = typeof guard === 'function';\n  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];\n  if (!isInline && !resolved) {\n    throw new Error(`Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`);\n  }\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved, context, event, snapshot);\n  }\n  const guardArgs = {\n    context,\n    event\n  };\n  const guardParams = isInline || typeof guard === 'string' ? undefined : 'params' in guard ? typeof guard.params === 'function' ? guard.params({\n    context,\n    event\n  }) : guard.params : undefined;\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams);\n  }\n  const builtinGuard = resolved;\n  return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n  );\n}\n\nconst isAtomicStateNode = stateNode => stateNode.type === 'atomic' || stateNode.type === 'final';\nfunction getChildren(stateNode) {\n  return Object.values(stateNode.states).filter(sn => sn.type !== 'history');\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n  const ancestors = [];\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n  return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n  const nodeSet = new Set(stateNodes);\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach(sn => nodeSet.add(sn));\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n  return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n  const childStateNodes = adjList.get(baseNode);\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n  const stateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n  return stateValue;\n}\nfunction getAdjList(stateNodes) {\n  const adjList = new Map();\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n      adjList.get(s.parent).push(s);\n    }\n  }\n  return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(s => s.type === 'final' && stateNodeSet.has(s));\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every(sn => isInFinalState(stateNodeSet, sn));\n  }\n  return stateNode.type === 'final';\n}\nconst isStateId = str => str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter(eventDescriptor => {\n    // check if transition is a wildcard transition,\n    // which matches any non-transient events\n    if (eventDescriptor === WILDCARD) {\n      return true;\n    }\n    if (!eventDescriptor.endsWith('.*')) {\n      return false;\n    }\n    const partialEventTokens = eventDescriptor.split('.');\n    const eventTokens = receivedEventType.split('.');\n    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {\n      const partialEventToken = partialEventTokens[tokenIndex];\n      const eventToken = eventTokens[tokenIndex];\n      if (partialEventToken === '*') {\n        const isLastToken = tokenIndex === partialEventTokens.length - 1;\n        return isLastToken;\n      }\n      if (partialEventToken !== eventToken) {\n        return false;\n      }\n    }\n    return true;\n  }).sort((a, b) => b.length - a.length).flatMap(key => stateNode.transitions.get(key));\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nfunction getDelayedTransitions(stateNode) {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n  const mutateEntryExit = delay => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n    stateNode.entry.push(raise(afterEvent, {\n      id: eventType,\n      delay\n    }));\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n  const delayedTransitions = Object.keys(afterConfig).flatMap(delay => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition = typeof configTransition === 'string' ? {\n      target: configTransition\n    } : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map(transition => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map(delayedTransition => {\n    const {\n      delay\n    } = delayedTransition;\n    return {\n      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n      delay\n    };\n  });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map(t => `#${t.id}`) : undefined\n    })\n  };\n  return transition;\n}\nfunction formatTransitions(stateNode) {\n  const transitions = new Map();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map(t => formatTransition(stateNode, descriptor, t)));\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n  const resolvedTarget = typeof _target === 'string' ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n    `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n  }\n  const transition = {\n    source: stateNode,\n    actions: !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n  return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map(target => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n        return targetStateNode;\n      } catch (err) {\n        throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n      }\n    } else {\n      throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n    }\n  });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n  const normalizedTarget = normalizeTarget(stateNode.config.target);\n  if (!normalizedTarget) {\n    return stateNode.parent.initial;\n  }\n  return {\n    target: normalizedTarget.map(t => typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t)\n  };\n}\nfunction isHistoryNode(stateNode) {\n  return stateNode.type === 'history';\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\nfunction getInitialStateNodes(stateNode) {\n  const set = new Set();\n  function iter(descStateNode) {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n  iter(stateNode);\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode, stateKey) {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nfunction getStateNodeByPath(stateNode, statePath) {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift();\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nfunction getStateNodes(stateNode, stateValue) {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n    }\n    return [stateNode, childStateNode];\n  }\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes = childStateKeys.map(subStateKey => getStateNode(stateNode, subStateKey)).filter(Boolean);\n  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    if (!subStateNode) {\n      return allSubStateNodes;\n    }\n    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n    return allSubStateNodes.concat(subStateNodes);\n  }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n  const subStateKeys = Object.keys(stateValue);\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n  const allInnerTransitions = [];\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n    if (!subStateValue) {\n      continue;\n    }\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n  return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n  return Object.keys(stateNode.states).map(key => stateNode.states[key]).filter(sn => sn.type === 'history');\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n  return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n  const filteredTransitions = new Set();\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set();\n    for (const t2 of filteredTransitions) {\n      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue))) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n  return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every(sn => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n  if (!transition.target) {\n    return [];\n  }\n  const targets = new Set();\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n  return [...targets];\n}\nfunction getTransitionDomain(transition, historyValue) {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n  if (!targetStates) {\n    return;\n  }\n  if (!transition.reenter && targetStates.every(target => target === transition.source || isDescendant(target, transition.source))) {\n    return transition.source;\n  }\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n  return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n  const statesToExit = new Set();\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n  return [...statesToExit];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nfunction microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n  if (!transitions.length) {\n    return currentSnapshot;\n  }\n  const mutStateNodeSet = new Set(currentSnapshot._nodes);\n  let historyValue = currentSnapshot.historyValue;\n  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n  let nextState = currentSnapshot;\n\n  // Exit states\n  if (!isInitial) {\n    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n  }\n\n  // Execute transition content\n  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap(t => t.actions), internalQueue, undefined);\n\n  // Enter states\n  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n  const nextStateNodes = [...mutStateNodeSet];\n  if (nextState.status === 'done') {\n    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b) => b.order - a.order).flatMap(state => state.exit), internalQueue, undefined);\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n      return nextState;\n    }\n    return cloneMachineSnapshot(nextState, {\n      _nodes: nextStateNodes,\n      historyValue\n    });\n  } catch (e) {\n    // TODO: Refactor this once proper error handling is implemented.\n    // See https://github.com/statelyai/rfcs/pull/4\n    throw e;\n  }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set();\n  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n  const completedNodes = new Set();\n  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(spawnChild(invokeDef.src, {\n        ...invokeDef,\n        syncSnapshot: !!invokeDef.onSnapshot\n      }));\n    }\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map(invokeDef => invokeDef.id));\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n      if (parent?.type === 'compound') {\n        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n      }\n      while (ancestorMarker?.type === 'parallel' && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n      });\n    }\n  }\n  return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n    for (const s of t.target || []) {\n      if (!isHistoryNode(s) && (\n      // if the target is different than the source then it will *definitely* be entered\n      t.source !== s ||\n      // we know that the domain can't lie within the source\n      // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n      t.source !== domain ||\n      // reentering transitions always enter the target, even if it's the source itself\n      t.reenter)) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n    }\n  }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n      }\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(sn => !isHistoryNode(sn))) {\n          if (![...statesToEnter].some(s => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n          }\n        }\n      }\n    }\n  }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter(sn => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some(s => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n      }\n    }\n  }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n  statesToExit.sort((a, b) => b.order - a.order);\n  let changedHistory;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate;\n      if (historyNode.history === 'deep') {\n        predicate = sn => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = sn => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= {\n        ...historyValue\n      };\n      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map(def => stopChild(def.id))], internalQueue, undefined);\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue];\n}\nfunction getAction(machine, actionType) {\n  return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n  const {\n    machine\n  } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline ? action :\n    // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n    // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n    // our logic below makes sure that we call those 2 \"variants\" correctly\n\n    getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n    const actionParams = isInline || typeof action === 'string' ? undefined : 'params' in action ? typeof action.params === 'function' ? action.params({\n      context: intermediateSnapshot.context,\n      event\n    }) : action.params : undefined;\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type: typeof action === 'string' ? action : typeof action === 'object' ? action.type : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n    const builtinAction = resolvedAction;\n    const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction,\n    // this holds all params\n    extra);\n    intermediateSnapshot = nextState;\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n    }\n  }\n  return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n  const retries = deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n    internalQueue,\n    deferredActorIds\n  }, retries);\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n  let nextSnapshot = snapshot;\n  const microstates = [];\n  function addMicrostate(microstate, event, transitions) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: microstate,\n      _transitions: transitions\n    });\n    microstates.push(microstate);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n      status: 'stopped'\n    });\n    addMicrostate(nextSnapshot, event, []);\n    return {\n      snapshot: nextSnapshot,\n      microstates\n    };\n  }\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostate(nextSnapshot, currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microstates\n      };\n    }\n    nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false,\n    // isInitial\n    internalQueue);\n    addMicrostate(nextSnapshot, currentEvent, transitions);\n  }\n  let shouldSelectEventlessTransitions = true;\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift();\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n  }\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n  return {\n    snapshot: nextSnapshot,\n    microstates\n  };\n}\nfunction stopChildren(nextState, event, actorScope) {\n  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map(child => stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n  return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n  const enabledTransitionSet = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, undefined))) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nfunction resolveStateValue(rootNode, stateValue) {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n\nfunction isMachineSnapshot(value) {\n  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n  return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n  return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n  const transitionData = this.machine.getTransitionData(this, event);\n  return !!transitionData?.length &&\n  // Check that at least one transition is not forbidden\n  transitionData.some(t => t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return {\n    ...jsonValues,\n    tags: Array.from(tags)\n  };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n  return this._nodes.reduce((acc, stateNode) => {\n    if (stateNode.meta !== undefined) {\n      acc[stateNode.id] = stateNode.meta;\n    }\n    return acc;\n  }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n  return {\n    status: config.status,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes),\n    tags: new Set(config._nodes.flatMap(sn => sn.tags)),\n    children: config.children,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n  return createMachineSnapshot({\n    ...snapshot,\n    ...config\n  }, snapshot.machine);\n}\nfunction serializeHistoryValue(historyValue) {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result = {};\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map(item => ({\n        id: item.id\n      }));\n    }\n  }\n  return result;\n}\nfunction getPersistedSnapshot(snapshot, options) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n  const childrenJson = {};\n  for (const id in children) {\n    const child = children[id];\n    childrenJson[id] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child._systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context),\n    children: childrenJson,\n    historyValue: serializeHistoryValue(jsonValues.historyValue)\n  };\n  return persisted;\n}\nfunction persistContext(contextPart) {\n  let copy;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n          ...contextPart\n        };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: value.id\n        };\n      } else {\n        const result = persistContext(value);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n            ...contextPart\n          };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n\nfunction resolveRaise(_, snapshot, args, actionParams, {\n  event: eventOrExpr,\n  id,\n  delay\n}, {\n  internalQueue\n}) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [snapshot, {\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }, undefined];\n}\nfunction executeRaise(actorScope, params) {\n  const {\n    event,\n    delay,\n    id\n  } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nfunction raise(eventOrExpr, options) {\n  function raise(_args, _params) {\n  }\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n  return raise;\n}\n\nexport { $$ACTOR_TYPE as $, Actor as A, getCandidates as B, resolveStateValue as C, getAllStateNodes as D, createMachineSnapshot as E, isInFinalState as F, macrostep as G, transitionNode as H, resolveActionsAndContext as I, createInitEvent as J, microstep as K, getInitialStateNodes as L, toStatePath as M, NULL_EVENT as N, isStateId as O, getStateNodeByPath as P, getPersistedSnapshot as Q, resolveReferencedActor as R, STATE_DELIMITER as S, XSTATE_ERROR as T, createErrorActorEvent as U, ProcessingStatus as V, cloneMachineSnapshot as W, XSTATE_STOP as X, and as a, isMachineSnapshot as b, createActor as c, getAllOwnEventDescriptors as d, toObserver as e, cancel as f, getStateNodes as g, spawnChild as h, interpret as i, stop as j, stopChild as k, mapValues as l, matchesState as m, not as n, or as o, pathToStateValue as p, formatTransitions as q, raise as r, stateIn as s, toArray as t, toTransitionConfigArray as u, formatTransition as v, evaluateGuard as w, createInvokeId as x, getDelayedTransitions as y, formatInitialTransition as z };\n","import { V as ProcessingStatus, R as resolveReferencedActor, c as createActor, W as cloneMachineSnapshot } from './raise-b0a4e862.esm.js';\n\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options) => {\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = createActor(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: typeof options?.input === 'function' ? options.input({\n          context,\n          event,\n          self: actorScope.self\n        }) : options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  }), undefined, undefined];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nfunction assign(assignment) {\n  function assign(_args, _params) {\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\nexport { assign as a };\n","import { S as STATE_DELIMITER, l as mapValues, t as toArray, q as formatTransitions, u as toTransitionConfigArray, v as formatTransition, N as NULL_EVENT, w as evaluateGuard, x as createInvokeId, y as getDelayedTransitions, z as formatInitialTransition, B as getCandidates, C as resolveStateValue, D as getAllStateNodes, g as getStateNodes, E as createMachineSnapshot, F as isInFinalState, G as macrostep, H as transitionNode, I as resolveActionsAndContext, J as createInitEvent, K as microstep, L as getInitialStateNodes, M as toStatePath, O as isStateId, P as getStateNodeByPath, Q as getPersistedSnapshot, R as resolveReferencedActor, c as createActor, $ as $$ACTOR_TYPE } from './raise-b0a4e862.esm.js';\nimport { a as assign } from './assign-c3259787.esm.js';\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(/** The raw config used to create the machine. */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */\n    this.key = void 0;\n    /** The unique ID of the state node. */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */\n    this.type = void 0;\n    /** The string path from the root machine node to this node. */\n    this.path = void 0;\n    /** The child state nodes. */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /** The action(s) to be executed upon entering the state node. */\n    this.entry = void 0;\n    /** The action(s) to be executed upon exiting the state node. */\n    this.exit = void 0;\n    /** The parent state node. */\n    this.parent = void 0;\n    /** The root machine node. */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const sourceName = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: sourceName,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: sourceName,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /** The mapping of events to transitions. */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(/** The raw config used to create the machine. */\n  config, implementations) {\n    this.config = config;\n    /** The machine's own version. */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope, []).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope, []).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue, undefined);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    function resolveHistoryReferencedState(root, referenced) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n      }\n    }\n    function reviveHistoryValue(root, historyValue) {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n          if (!resolved) {\n            continue;\n          }\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n    const revivedHistoryValue = reviveHistoryValue(this.root, snapshot.historyValue);\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value))),\n      historyValue: revivedHistoryValue\n    }, this);\n    const seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\nexport { StateMachine as S, StateNode as a };\n","export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.esm.js';\nimport { t as toArray, c as createActor } from './raise-b0a4e862.esm.js';\nexport { A as Actor, d as __unsafe_getAllOwnEventDescriptors, a as and, f as cancel, c as createActor, g as getStateNodes, i as interpret, b as isMachineSnapshot, m as matchesState, n as not, o as or, p as pathToStateValue, r as raise, h as spawnChild, s as stateIn, j as stop, k as stopChild, e as toObserver } from './raise-b0a4e862.esm.js';\nimport { S as StateMachine } from './StateMachine-c88ea5dd.esm.js';\nexport { S as StateMachine, a as StateNode } from './StateMachine-c88ea5dd.esm.js';\nexport { S as SpecialTargets, e as emit, a as enqueueActions, f as forwardTo, l as log, s as sendParent, b as sendTo } from './log-1c257a58.esm.js';\nexport { a as assign } from './assign-c3259787.esm.js';\nimport '../dev/dist/xstate-dev.esm.js';\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n  return inertActorScope;\n}\n\n/** @deprecated Use `initialTransition(…)` instead. */\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\n\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction transition(logic, snapshot, event) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.transition(snapshot, event, actorScope);\n  return [nextSnapshot, executableActions];\n}\n\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */\nfunction initialTransition(logic, ...[input]) {\n  const executableActions = [];\n  const actorScope = createInertActorScope(logic);\n  actorScope.actionExecutor = action => {\n    executableActions.push(action);\n  };\n  const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n  return [nextSnapshot, executableActions];\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    const {\n      signal\n    } = resolvedOptions;\n    if (signal?.aborted) {\n      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n      rej(signal.reason);\n      return;\n    }\n    let done = false;\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      dispose();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n      if (abortListener) {\n        signal.removeEventListener('abort', abortListener);\n      }\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n\n    /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */\n    let abortListener;\n    // eslint-disable-next-line prefer-const\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n\n    // only define the `abortListener` if the `signal` option is provided\n    if (signal) {\n      abortListener = () => {\n        dispose();\n        // XState does not \"own\" the signal, so we should reject with its reason (if any)\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(signal.reason);\n      };\n      signal.addEventListener('abort', abortListener);\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\nexport { SimulatedClock, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, initialTransition, setup, toPromise, transition, waitFor };\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","\"use strict\";\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = require(\"./utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports.default = u64;\n//# sourceMappingURL=_u64.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = require(\"./_md.js\");\nconst u64 = require(\"./_u64.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = require(\"./sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha224 = sha2_ts_1.sha224;\n//# sourceMappingURL=sha256.js.map","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n\nvar base58 = require('bs58')\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar { sha256 } = require('@noble/hashes/sha256')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","export const uint8ArrayFromHexString = (hexString) => {\n    if (hexString.length % 2 !== 0) {\n        throw new Error(\"Hex string must have an even length\");\n    }\n    const bytes = new Uint8Array(hexString.length / 2);\n    for (let i = 0; i < hexString.length; i += 2) {\n        bytes[i >> 1] = parseInt(hexString.slice(i, i + 2), 16);\n    }\n    return bytes;\n};\nexport const uint8ArrayToHexString = (data) => {\n    return Array.from(data, byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n};\n","import * as Uuid from \"uuid\";\nimport bs58check from \"bs58check\";\nimport { uint8ArrayFromHexString, uint8ArrayToHexString, } from \"./helpers/bufferFromHex.js\";\nexport const urlPrefix = \"automerge:\";\n/** Given an Automerge URL, returns the DocumentId in both base58check-encoded form and binary form */\nexport const parseAutomergeUrl = (url) => {\n    const [baseUrl, headsSection, ...rest] = url.split(\"#\");\n    if (rest.length > 0) {\n        throw new Error(\"Invalid URL: contains multiple heads sections\");\n    }\n    const regex = new RegExp(`^${urlPrefix}(\\\\w+)$`);\n    const [, docMatch] = baseUrl.match(regex) || [];\n    const documentId = docMatch;\n    const binaryDocumentId = documentIdToBinary(documentId);\n    if (!binaryDocumentId)\n        throw new Error(\"Invalid document URL: \" + url);\n    if (headsSection === undefined)\n        return { binaryDocumentId, documentId };\n    const heads = (headsSection === \"\" ? [] : headsSection.split(\"|\"));\n    const hexHeads = heads.map(head => {\n        try {\n            return uint8ArrayToHexString(bs58check.decode(head));\n        }\n        catch (e) {\n            throw new Error(`Invalid head in URL: ${head}`);\n        }\n    });\n    return { binaryDocumentId, hexHeads, documentId, heads };\n};\n/**\n * Given a documentId in either binary or base58check-encoded form, returns an Automerge URL.\n * Throws on invalid input.\n */\nexport const stringifyAutomergeUrl = (arg) => {\n    if (arg instanceof Uint8Array || typeof arg === \"string\") {\n        return (urlPrefix +\n            (arg instanceof Uint8Array\n                ? binaryToDocumentId(arg)\n                : arg));\n    }\n    const { documentId, heads = undefined } = arg;\n    if (documentId === undefined)\n        throw new Error(\"Invalid documentId: \" + documentId);\n    const encodedDocumentId = documentId instanceof Uint8Array\n        ? binaryToDocumentId(documentId)\n        : documentId;\n    let url = `${urlPrefix}${encodedDocumentId}`;\n    if (heads !== undefined) {\n        heads.forEach(head => {\n            try {\n                bs58check.decode(head);\n            }\n            catch (e) {\n                throw new Error(`Invalid head: ${head}`);\n            }\n        });\n        url += \"#\" + heads.join(\"|\");\n    }\n    return url;\n};\n/** Helper to extract just the heads from a URL if they exist */\nexport const getHeadsFromUrl = (url) => {\n    const { heads } = parseAutomergeUrl(url);\n    return heads;\n};\nexport const anyDocumentIdToAutomergeUrl = (id) => isValidAutomergeUrl(id)\n    ? id\n    : isValidDocumentId(id)\n        ? stringifyAutomergeUrl({ documentId: id })\n        : isValidUuid(id)\n            ? parseLegacyUUID(id)\n            : undefined;\n/**\n * Given a string, returns true if it is a valid Automerge URL. This function also acts as a type\n * discriminator in Typescript.\n */\nexport const isValidAutomergeUrl = (str) => {\n    if (typeof str !== \"string\" || !str || !str.startsWith(urlPrefix))\n        return false;\n    try {\n        const { documentId, heads } = parseAutomergeUrl(str);\n        if (!isValidDocumentId(documentId))\n            return false;\n        if (heads &&\n            !heads.every(head => {\n                try {\n                    bs58check.decode(head);\n                    return true;\n                }\n                catch {\n                    return false;\n                }\n            }))\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const isValidDocumentId = (str) => {\n    if (typeof str !== \"string\")\n        return false;\n    // try to decode from base58\n    const binaryDocumentID = documentIdToBinary(str);\n    if (binaryDocumentID === undefined)\n        return false; // invalid base58check encoding\n    // confirm that the document ID is a valid UUID\n    const documentId = Uuid.stringify(binaryDocumentID);\n    return Uuid.validate(documentId);\n};\nexport const isValidUuid = (str) => typeof str === \"string\" && Uuid.validate(str);\n/**\n * Returns a new Automerge URL with a random UUID documentId. Called by Repo.create(), and also used by tests.\n */\nexport const generateAutomergeUrl = () => {\n    const documentId = Uuid.v4(null, new Uint8Array(16));\n    return stringifyAutomergeUrl({ documentId });\n};\nexport const documentIdToBinary = (docId) => bs58check.decodeUnsafe(docId);\nexport const binaryToDocumentId = (docId) => bs58check.encode(docId);\nexport const encodeHeads = (heads) => heads.map(h => bs58check.encode(uint8ArrayFromHexString(h)));\nexport const decodeHeads = (heads) => heads.map(h => uint8ArrayToHexString(bs58check.decode(h)));\nexport const parseLegacyUUID = (str) => {\n    if (!Uuid.validate(str))\n        return undefined;\n    const documentId = Uuid.parse(str);\n    return stringifyAutomergeUrl({ documentId });\n};\n/**\n * Given any valid expression of a document ID, returns a DocumentId in base58check-encoded form.\n *\n * Currently supports:\n * - base58check-encoded DocumentId\n * - Automerge URL\n * - legacy UUID\n * - binary DocumentId\n *\n * Throws on invalid input.\n */\nexport const interpretAsDocumentId = (id) => {\n    // binary\n    if (id instanceof Uint8Array)\n        return binaryToDocumentId(id);\n    // url\n    if (isValidAutomergeUrl(id))\n        return parseAutomergeUrl(id).documentId;\n    // base58check\n    if (isValidDocumentId(id))\n        return id;\n    // legacy UUID\n    if (isValidUuid(id)) {\n        console.warn(\"Future versions will not support UUIDs as document IDs; use Automerge URLs instead.\");\n        const binaryDocumentID = Uuid.parse(id);\n        return binaryToDocumentId(binaryDocumentID);\n    }\n    // none of the above\n    throw new Error(`Invalid AutomergeUrl: '${id}'`);\n};\n","let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ >= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value << BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) => {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i < length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length < position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 && !(buffer.byteOffset & 1) ||\n\t\t\t\t\tbytesPerElement === 4 && !(buffer.byteOffset & 3) ||\n\t\t\t\t\tbytesPerElement === 8 && !(buffer.byteOffset & 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' && globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures > 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap && !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r => this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i < l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength > maxSharedStructures && !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length > 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions & THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length > maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate && encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length > maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () => {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) => {\n\t\t\t\tlet threshold = options && options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count > threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared && this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition >= 0) {\n\t\t\t\t\t\tif (packedPosition < 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition & 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) >> 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) >> 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount > (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition < 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues && !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value >= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value >= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag && extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag < 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag < 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag >> 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag & 0xff\n\t\t\t\t\t\t\t\t} else if (tag > -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON && value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(64)) && value >= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value >= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value & BigInt(0xff)));\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(object, skipValues) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k => this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] & 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId &= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId >= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId < maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId >> 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId & 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length < 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value && typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value && (typeof value === 'object' || position - start > chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable && position > start) yield target.subarray(start, position);\n\t\t\telse if (position - start > chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start > chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options && options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared => (existingShared && existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) => this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length < 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length < 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length < 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length > 3) {\n\t\t\t\tif (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length > 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i < l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine && size > 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length < 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length < 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length >= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1)\n\tfor (let id = 0; id < idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id >> 8\n\t\t\tserialized[position] = id & 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n","import { Encoder, decode as cborXdecode } from \"cbor-x\";\nexport function encode(obj) {\n    const encoder = new Encoder({ tagUint8Array: false, useRecords: false });\n    return encoder.encode(obj);\n}\nexport function decode(buf) {\n    return cborXdecode(buf);\n}\n","export const arraysAreEqual = (a, b) => a.length === b.length && a.every((element, index) => element === b[index]);\n","import { arraysAreEqual } from \"./arraysAreEqual.js\";\nexport const headsAreSame = (a, b) => {\n    return arraysAreEqual(a, b);\n};\n","/* c8 ignore start */\n/**\n * If `promise` is resolved before `t` ms elapse, the timeout is cleared and the result of the\n * promise is returned. If the timeout ends first, a `TimeoutError` is thrown.\n */\nexport const withTimeout = async (promise, t) => {\n    let timeoutId;\n    const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new TimeoutError(`withTimeout: timed out after ${t}ms`)), t);\n    });\n    try {\n        return await Promise.race([promise, timeoutPromise]);\n    }\n    finally {\n        clearTimeout(timeoutId);\n    }\n};\nexport class TimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"TimeoutError\";\n    }\n}\n/* c8 ignore end */\n","import { next as A } from \"@automerge/automerge/slim\";\nimport debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { assertEvent, assign, createActor, setup, waitFor } from \"xstate\";\nimport { decodeHeads, encodeHeads, stringifyAutomergeUrl, } from \"./AutomergeUrl.js\";\nimport { encode } from \"./helpers/cbor.js\";\nimport { headsAreSame } from \"./helpers/headsAreSame.js\";\nimport { withTimeout } from \"./helpers/withTimeout.js\";\n/**\n * A DocHandle is a wrapper around a single Automerge document that lets us listen for changes and\n * notify the network and storage of new changes.\n *\n * @remarks\n * A `DocHandle` represents a document which is being managed by a {@link Repo}. You shouldn't ever\n * instantiate this yourself. To obtain `DocHandle` use {@link Repo.find} or {@link Repo.create}.\n *\n * To modify the underlying document use either {@link DocHandle.change} or\n * {@link DocHandle.changeAt}. These methods will notify the `Repo` that some change has occured and\n * the `Repo` will save any new changes to the attached {@link StorageAdapter} and send sync\n * messages to connected peers.\n */\nexport class DocHandle extends EventEmitter {\n    documentId;\n    #log;\n    /** The XState actor running our state machine.  */\n    #machine;\n    /** If set, this handle will only show the document at these heads */\n    #fixedHeads;\n    /** The last known state of our document. */\n    #prevDocState = A.init();\n    /** How long to wait before giving up on a document. (Note that a document will be marked\n     * unavailable much sooner if all known peers respond that they don't have it.) */\n    #timeoutDelay = 60_000;\n    /** A dictionary mapping each peer to the last known heads we have. */\n    #syncInfoByStorageId = {};\n    /** Cache for view handles, keyed by the stringified heads */\n    #viewCache = new Map();\n    /** @hidden */\n    constructor(documentId, options = {}) {\n        super();\n        this.documentId = documentId;\n        if (\"timeoutDelay\" in options && options.timeoutDelay) {\n            this.#timeoutDelay = options.timeoutDelay;\n        }\n        if (\"heads\" in options) {\n            this.#fixedHeads = options.heads;\n        }\n        const doc = A.init();\n        this.#log = debug(`automerge-repo:dochandle:${this.documentId.slice(0, 5)}`);\n        const delay = this.#timeoutDelay;\n        const machine = setup({\n            types: {\n                context: {},\n                events: {},\n            },\n            actions: {\n                /** Update the doc using the given callback and put the modified doc in context */\n                onUpdate: assign(({ context, event }) => {\n                    const oldDoc = context.doc;\n                    assertEvent(event, UPDATE);\n                    const { callback } = event.payload;\n                    const doc = callback(oldDoc);\n                    return { doc };\n                }),\n                onDelete: assign(() => {\n                    this.emit(\"delete\", { handle: this });\n                    return { doc: A.init() };\n                }),\n                onUnavailable: assign(() => {\n                    return { doc: A.init() };\n                }),\n                onUnload: assign(() => {\n                    return { doc: A.init() };\n                }),\n            },\n        }).createMachine({\n            /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAYgFUAFAEQEEAVAUQG0AGAXUVAAcB7WXAC64e+TiAAeiAOwAOAKwA6ACxSAzKqks1ATjlTdAGhABPRAFolAJksKN2y1KtKAbFLla5AX09G0WPISkVAwAMgyMrBxIILz8QiJikggAjCzOijKqLEqqybJyLizaRqYIFpbJtro5Uo7J2o5S3r4YOATECrgQADZgJADCAEoM9MzsYrGCwqLRSeoyCtra8pa5adquySXmDjY5ac7JljLJeepKzSB+bYGdPX0AYgCSAHJUkRN8UwmziM7HCgqyVcUnqcmScmcMm2ZV2yiyzkOx1OalUFx8V1aAQ63R46AgBCgJGGAEUyAwAMp0D7RSbxGagJKHFgKOSWJTJGRSCosCpKaEmRCqbQKU5yXINeTaer6LwY67YogKXH4wkkKgAeX6AH1hjQqABNGncL70xKIJQ5RY5BHOJag6wwpRyEWImQVeT1aWrVSXBXtJUqgn4Ik0ADqNCedG1L3CYY1gwA0saYqbpuaEG4pKLksKpFDgcsCjDhTnxTKpTLdH6sQGFOgAO7oKYhl5gAQNngAJwA1iRY3R40ndSNDSm6enfpm5BkWAVkvy7bpuTCKq7ndZnfVeSwuTX-HWu2AAI4AVzgQhD6q12rILxoADVIyEaAAhMLjtM-RmIE4LVSQi4nLLDIGzOCWwLKA0cgyLBoFWNy+43B0R5nheaqajqepjuMtJfgyEh-FoixqMCoKqOyhzgYKCDOq6UIeuCSxHOoSGKgop74OgABuzbdOgABGvTXlho5GrhJpxJOP4pLulT6KoMhpJY2hzsWNF0QobqMV6LG+pc+A8BAcBiP6gSfFJ36EQgKksksKxrHamwwmY7gLKB85QjBzoAWxdZdL0FnfARST8ooLC7qoTnWBU4pyC5ViVMKBQaHUDQuM4fm3EGhJBWaU7-CysEAUp3LpEpWw0WYRw2LmqzgqciIsCxWUdI2zaXlAbYdt2PZ5dJ1n5jY2iJY1ikOIcMJHCyUWHC62hRZkUVNPKta3Kh56wJ1-VWUyzhFc64JWJCtQNBBzhQW4cHwbsrVKpxPF8YJgV4ZZIWIKkiKiiNSkqZYWjzCWaQ5hFh0AcCuR3QoR74qUknBRmzholpv3OkpRQNNRpTzaKTWKbIWR5FDxm9AIkA7e9skUYCWayLILBZGoLkUSKbIyIdpxHPoyTeN4QA */\n            // You can use the XState extension for VS Code to visualize this machine.\n            // Or, you can see this static visualization (last updated April 2024): https://stately.ai/registry/editor/d7af9b58-c518-44f1-9c36-92a238b04a7a?machineId=91c387e7-0f01-42c9-a21d-293e9bf95bb7\n            initial: \"idle\",\n            context: { documentId, doc },\n            on: {\n                UPDATE: { actions: \"onUpdate\" },\n                UNLOAD: \".unloaded\",\n                DELETE: \".deleted\",\n            },\n            states: {\n                idle: {\n                    on: {\n                        BEGIN: \"loading\",\n                    },\n                },\n                loading: {\n                    on: {\n                        REQUEST: \"requesting\",\n                        DOC_READY: \"ready\",\n                    },\n                    after: { [delay]: \"unavailable\" },\n                },\n                requesting: {\n                    on: {\n                        DOC_UNAVAILABLE: \"unavailable\",\n                        DOC_READY: \"ready\",\n                    },\n                    after: { [delay]: \"unavailable\" },\n                },\n                unavailable: {\n                    entry: \"onUnavailable\",\n                    on: { DOC_READY: \"ready\" },\n                },\n                ready: {},\n                unloaded: {\n                    entry: \"onUnload\",\n                    on: {\n                        RELOAD: \"loading\",\n                    },\n                },\n                deleted: { entry: \"onDelete\", type: \"final\" },\n            },\n        });\n        // Instantiate the state machine\n        this.#machine = createActor(machine);\n        // Listen for state transitions\n        this.#machine.subscribe(state => {\n            const before = this.#prevDocState;\n            const after = state.context.doc;\n            this.#log(`→ ${state.value} %o`, after);\n            // if the document has changed, emit a change event\n            this.#checkForChanges(before, after);\n        });\n        // Start the machine, and send a create or find event to get things going\n        this.#machine.start();\n        this.begin();\n    }\n    // PRIVATE\n    /** Returns the current document, regardless of state */\n    get #doc() {\n        return this.#machine?.getSnapshot().context.doc;\n    }\n    /** Returns the docHandle's state (READY, etc.) */\n    get #state() {\n        return this.#machine?.getSnapshot().value;\n    }\n    /** Returns a promise that resolves when the docHandle is in one of the given states */\n    #statePromise(awaitStates) {\n        const awaitStatesArray = Array.isArray(awaitStates)\n            ? awaitStates\n            : [awaitStates];\n        return waitFor(this.#machine, s => awaitStatesArray.some(state => s.matches(state)), \n        // use a longer delay here so as not to race with other delays\n        { timeout: this.#timeoutDelay * 2 });\n    }\n    /**\n     * Update the document with whatever the result of callback is\n     *\n     * This is necessary instead of directly calling\n     * `this.#machine.send({ type: UPDATE, payload: { callback } })` because we\n     * want to catch any exceptions that the callback might throw, then rethrow\n     * them after the state machine has processed the update.\n     */\n    #sendUpdate(callback) {\n        // This is kind of awkward. we have to pass the callback to xstate and wait for it to run it.\n        // We're relying here on the fact that xstate runs everything synchronously, so by the time\n        // `send` returns we know that the callback will have been run and so `thrownException`  will\n        // be set if the callback threw an error.\n        let thrownException = null;\n        this.#machine.send({\n            type: UPDATE,\n            payload: {\n                callback: doc => {\n                    try {\n                        return callback(doc);\n                    }\n                    catch (e) {\n                        thrownException = e;\n                        return doc;\n                    }\n                },\n            },\n        });\n        if (thrownException) {\n            // If the callback threw an error, we throw it here so the caller can handle it\n            throw thrownException;\n        }\n    }\n    /**\n     * Called after state transitions. If the document has changed, emits a change event. If we just\n     * received the document for the first time, signal that our request has been completed.\n     */\n    #checkForChanges(before, after) {\n        const beforeHeads = A.getHeads(before);\n        const afterHeads = A.getHeads(after);\n        const docChanged = !headsAreSame(encodeHeads(afterHeads), encodeHeads(beforeHeads));\n        if (docChanged) {\n            this.emit(\"heads-changed\", { handle: this, doc: after });\n            const patches = A.diff(after, beforeHeads, afterHeads);\n            if (patches.length > 0) {\n                this.emit(\"change\", {\n                    handle: this,\n                    doc: after,\n                    patches,\n                    // TODO: pass along the source (load/change/network)\n                    patchInfo: { before, after, source: \"change\" },\n                });\n            }\n            // If we didn't have the document yet, signal that we now do\n            if (!this.isReady())\n                this.#machine.send({ type: DOC_READY });\n        }\n        this.#prevDocState = after;\n    }\n    // PUBLIC\n    /** Our documentId in Automerge URL form.\n     */\n    get url() {\n        return stringifyAutomergeUrl({\n            documentId: this.documentId,\n            heads: this.#fixedHeads,\n        });\n    }\n    /**\n     * @returns true if the document is ready for accessing or changes.\n     *\n     * Note that for documents already stored locally this occurs before synchronization with any\n     * peers. We do not currently have an equivalent `whenSynced()`.\n     */\n    isReady = () => this.inState([\"ready\"]);\n    /**\n     * @returns true if the document has been unloaded.\n     *\n     * Unloaded documents are freed from memory but not removed from local storage. It's not currently\n     * possible at runtime to reload an unloaded document.\n     */\n    isUnloaded = () => this.inState([\"unloaded\"]);\n    /**\n     * @returns true if the document has been marked as deleted.\n     *\n     * Deleted documents are removed from local storage and the sync process. It's not currently\n     * possible at runtime to undelete a document.\n     */\n    isDeleted = () => this.inState([\"deleted\"]);\n    /**\n     * @returns true if the document is currently unavailable.\n     *\n     * This will be the case if the document is not found in storage and no peers have shared it with us.\n     */\n    isUnavailable = () => this.inState([\"unavailable\"]);\n    /**\n     * @returns true if the handle is in one of the given states.\n     */\n    inState = (states) => states.some(s => this.#machine.getSnapshot().matches(s));\n    /** @hidden */\n    get state() {\n        return this.#machine.getSnapshot().value;\n    }\n    /**\n     * @returns a promise that resolves when the document is in one of the given states (if no states\n     * are passed, when the document is ready)\n     *\n     * Use this to block until the document handle has finished loading. The async equivalent to\n     * checking `inState()`.\n     */\n    async whenReady(awaitStates = [\"ready\"]) {\n        await withTimeout(this.#statePromise(awaitStates), this.#timeoutDelay);\n    }\n    /**\n     * Returns the current state of the Automerge document this handle manages.\n     *\n     * @returns the current document\n     * @throws on deleted and unavailable documents\n     *\n     */\n    doc() {\n        if (!this.isReady())\n            throw new Error(\"DocHandle is not ready\");\n        if (this.#fixedHeads) {\n            return A.view(this.#doc, decodeHeads(this.#fixedHeads));\n        }\n        return this.#doc;\n    }\n    /**\n     *\n     * @deprecated */\n    docSync() {\n        console.warn(\"docSync is deprecated. Use doc() instead. This function will be removed as part of the 2.0 release.\");\n        return this.doc();\n    }\n    /**\n     * Returns the current \"heads\" of the document, akin to a git commit.\n     * This precisely defines the state of a document.\n     * @returns the current document's heads, or undefined if the document is not ready\n     */\n    heads() {\n        if (!this.isReady())\n            throw new Error(\"DocHandle is not ready\");\n        if (this.#fixedHeads) {\n            return this.#fixedHeads;\n        }\n        return encodeHeads(A.getHeads(this.#doc));\n    }\n    begin() {\n        this.#machine.send({ type: BEGIN });\n    }\n    /**\n     * Returns an array of all past \"heads\" for the document in topological order.\n     *\n     * @remarks\n     * A point-in-time in an automerge document is an *array* of heads since there may be\n     * concurrent edits. This API just returns a topologically sorted history of all edits\n     * so every previous entry will be (in some sense) before later ones, but the set of all possible\n     * history views would be quite large under concurrency (every thing in each branch against each other).\n     * There might be a clever way to think about this, but we haven't found it yet, so for now at least\n     * we present a single traversable view which excludes concurrency.\n     * @returns UrlHeads[] - The individual heads for every change in the document. Each item is a tagged string[1].\n     */\n    history() {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        // This just returns all the heads as individual strings.\n        return A.topoHistoryTraversal(this.#doc).map(h => encodeHeads([h]));\n    }\n    /**\n     * Creates a fixed \"view\" of an automerge document at the given point in time represented\n     * by the `heads` passed in. The return value is the same type as doc() and will return\n     * undefined if the object hasn't finished loading.\n     *\n     * @remarks\n     * Note that our Typescript types do not consider change over time and the current version\n     * of Automerge doesn't check types at runtime, so if you go back to an old set of heads\n     * that doesn't match the heads here, Typescript will not save you.\n     *\n     * @argument heads - The heads to view the document at. See history().\n     * @returns DocHandle<T> at the time of `heads`\n     */\n    view(heads) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is not ready. Check \\`handle.isReady()\\` before calling view().`);\n        }\n        // Create a cache key from the heads\n        const cacheKey = JSON.stringify(heads);\n        // Check if we have a cached handle for these heads\n        const cachedHandle = this.#viewCache.get(cacheKey);\n        if (cachedHandle) {\n            return cachedHandle;\n        }\n        // Create a new handle with the same documentId but fixed heads\n        const handle = new DocHandle(this.documentId, {\n            heads,\n            timeoutDelay: this.#timeoutDelay,\n        });\n        handle.update(() => A.clone(this.#doc));\n        handle.doneLoading();\n        // Store in cache\n        this.#viewCache.set(cacheKey, handle);\n        return handle;\n    }\n    /**\n     * Returns a set of Patch operations that will move a materialized document from one state to another\n     * if applied.\n     *\n     * @remarks\n     * We allow specifying either:\n     * - Two sets of heads to compare directly\n     * - A single set of heads to compare against our current heads\n     * - Another DocHandle to compare against (which must share history with this document)\n     *\n     * @throws Error if the documents don't share history or if either document is not ready\n     * @returns Automerge patches that go from one document state to the other\n     */\n    diff(first, second) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is not ready. Check \\`handle.isReady()\\` before calling diff().`);\n        }\n        const doc = this.#doc;\n        if (!doc)\n            throw new Error(\"Document not available\");\n        // If first argument is a DocHandle\n        if (first instanceof DocHandle) {\n            if (!first.isReady()) {\n                throw new Error(\"Cannot diff against a handle that isn't ready\");\n            }\n            const otherHeads = first.heads();\n            if (!otherHeads)\n                throw new Error(\"Other document's heads not available\");\n            // Create a temporary merged doc to verify shared history and compute diff\n            const mergedDoc = A.merge(A.clone(doc), first.doc());\n            // Use the merged doc to compute the diff\n            return A.diff(mergedDoc, decodeHeads(this.heads()), decodeHeads(otherHeads));\n        }\n        // Otherwise treat as heads\n        const from = second ? first : (this.heads() || []);\n        const to = second ? second : first;\n        return A.diff(doc, decodeHeads(from), decodeHeads(to));\n    }\n    /**\n     * `metadata(head?)` allows you to look at the metadata for a change\n     * this can be used to build history graphs to find commit messages and edit times.\n     * this interface.\n     *\n     * @remarks\n     * I'm really not convinced this is the right way to surface this information so\n     * I'm leaving this API \"hidden\".\n     *\n     * @hidden\n     */\n    metadata(change) {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        if (!change) {\n            change = this.heads()[0];\n        }\n        // we return undefined instead of null by convention in this API\n        return (A.inspectChange(this.#doc, decodeHeads([change])[0]) ||\n            undefined);\n    }\n    /**\n     * `update` is called any time we have a new document state; could be\n     * from a local change, a remote change, or a new document from storage.\n     * Does not cause state changes.\n     * @hidden\n     */\n    update(callback) {\n        this.#sendUpdate(callback);\n    }\n    /**\n     * `doneLoading` is called by the repo after it decides it has all the changes\n     * it's going to get during setup. This might mean it was created locally,\n     * or that it was loaded from storage, or that it was received from a peer.\n     */\n    doneLoading() {\n        this.#machine.send({ type: DOC_READY });\n    }\n    /**\n     * Called by the repo when a doc handle changes or we receive new remote heads.\n     * @hidden\n     */\n    setSyncInfo(storageId, syncInfo) {\n        this.#syncInfoByStorageId[storageId] = syncInfo;\n        this.emit(\"remote-heads\", {\n            storageId,\n            heads: syncInfo.lastHeads,\n            timestamp: syncInfo.lastSyncTimestamp,\n        });\n    }\n    /** Returns the heads of the storageId.\n     *\n     * @deprecated Use getSyncInfo instead.\n     */\n    getRemoteHeads(storageId) {\n        return this.#syncInfoByStorageId[storageId]?.lastHeads;\n    }\n    /** Returns the heads and the timestamp of the last update for the storageId. */\n    getSyncInfo(storageId) {\n        return this.#syncInfoByStorageId[storageId];\n    }\n    /**\n     * All changes to an Automerge document should be made through this method.\n     * Inside the callback, the document should be treated as mutable: all edits will be recorded\n     * using a Proxy and translated into operations as part of a single recorded \"change\".\n     *\n     * Note that assignment via ES6 spread operators will result in *replacing* the object\n     * instead of mutating it which will prevent clean merges. This may be what you want, but\n     * `doc.foo = { ...doc.foo, bar: \"baz\" }` is not equivalent to `doc.foo.bar = \"baz\"`.\n     *\n     * Local changes will be stored (by the StorageSubsystem) and synchronized (by the\n     * DocSynchronizer) to any peers you are sharing it with.\n     *\n     * @param callback - A function that takes the current document and mutates it.\n     *\n     */\n    change(callback, options = {}) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is in ${this.state} and not ready. Check \\`handle.isReady()\\` before accessing the document.`);\n        }\n        if (this.#fixedHeads) {\n            throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);\n        }\n        this.#sendUpdate(doc => A.change(doc, options, callback));\n    }\n    /**\n     * Makes a change as if the document were at `heads`.\n     *\n     * @returns A set of heads representing the concurrent change that was made.\n     */\n    changeAt(heads, callback, options = {}) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is not ready. Check \\`handle.isReady()\\` before accessing the document.`);\n        }\n        if (this.#fixedHeads) {\n            throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);\n        }\n        let resultHeads = undefined;\n        this.#sendUpdate(doc => {\n            const result = A.changeAt(doc, decodeHeads(heads), options, callback);\n            resultHeads = result.newHeads ? encodeHeads(result.newHeads) : undefined;\n            return result.newDoc;\n        });\n        // the callback above will always run before we get here, so this should always contain the new heads\n        return resultHeads;\n    }\n    /**\n     * Check if the document can be change()ed. Currently, documents can be\n     * edited unless we are viewing a particular point in time.\n     *\n     * @remarks It is technically possible to back-date changes using changeAt(),\n     *          but we block it for usability reasons when viewing a particular point in time.\n     *          To make changes in the past, use the primary document handle with no heads set.\n     *\n     * @returns boolean indicating whether changes are possible\n     */\n    isReadOnly() {\n        return !!this.#fixedHeads;\n    }\n    /**\n     * Merges another document into this document. Any peers we are sharing changes with will be\n     * notified of the changes resulting from the merge.\n     *\n     * @returns the merged document.\n     *\n     * @throws if either document is not ready or if `otherHandle` is unavailable.\n     */\n    merge(\n    /** the handle of the document to merge into this one */\n    otherHandle) {\n        if (!this.isReady() || !otherHandle.isReady()) {\n            throw new Error(\"Both handles must be ready to merge\");\n        }\n        if (this.#fixedHeads) {\n            throw new Error(`DocHandle#${this.documentId} is in view-only mode at specific heads. Use clone() to create a new document from this state.`);\n        }\n        const mergingDoc = otherHandle.doc();\n        this.update(doc => {\n            return A.merge(doc, mergingDoc);\n        });\n    }\n    /**\n     * Updates the internal state machine to mark the document unavailable.\n     * @hidden\n     */\n    unavailable() {\n        this.#machine.send({ type: DOC_UNAVAILABLE });\n    }\n    /**\n     * Called by the repo either when the document is not found in storage.\n     * @hidden\n     * */\n    request() {\n        if (this.#state === \"loading\")\n            this.#machine.send({ type: REQUEST });\n    }\n    /** Called by the repo to free memory used by the document. */\n    unload() {\n        this.#machine.send({ type: UNLOAD });\n    }\n    /** Called by the repo to reuse an unloaded handle. */\n    reload() {\n        this.#machine.send({ type: RELOAD });\n    }\n    /** Called by the repo when the document is deleted. */\n    delete() {\n        this.#machine.send({ type: DELETE });\n    }\n    /**\n     * Sends an arbitrary ephemeral message out to all reachable peers who would receive sync messages\n     * from you. It has no guarantee of delivery, and is not persisted to the underlying automerge doc\n     * in any way. Messages will have a sending PeerId but this is *not* a useful user identifier (a\n     * user could have multiple tabs open and would appear as multiple PeerIds). Every message source\n     * must have a unique PeerId.\n     */\n    broadcast(message) {\n        this.emit(\"ephemeral-message-outbound\", {\n            handle: this,\n            data: new Uint8Array(encode(message)),\n        });\n    }\n    metrics() {\n        return A.stats(this.#doc);\n    }\n}\n// STATE MACHINE TYPES & CONSTANTS\n// state\n/**\n * Possible internal states for a DocHandle\n */\nexport const HandleState = {\n    /** The handle has been created but not yet loaded or requested */\n    IDLE: \"idle\",\n    /** We are waiting for storage to finish loading */\n    LOADING: \"loading\",\n    /** We are waiting for someone in the network to respond to a sync request */\n    REQUESTING: \"requesting\",\n    /** The document is available */\n    READY: \"ready\",\n    /** The document has been unloaded from the handle, to free memory usage */\n    UNLOADED: \"unloaded\",\n    /** The document has been deleted from the repo */\n    DELETED: \"deleted\",\n    /** The document was not available in storage or from any connected peers */\n    UNAVAILABLE: \"unavailable\",\n};\nexport const { IDLE, LOADING, REQUESTING, READY, UNLOADED, DELETED, UNAVAILABLE, } = HandleState;\nconst BEGIN = \"BEGIN\";\nconst REQUEST = \"REQUEST\";\nconst DOC_READY = \"DOC_READY\";\nconst UPDATE = \"UPDATE\";\nconst UNLOAD = \"UNLOAD\";\nconst RELOAD = \"RELOAD\";\nconst DELETE = \"DELETE\";\nconst TIMEOUT = \"TIMEOUT\";\nconst DOC_UNAVAILABLE = \"DOC_UNAVAILABLE\";\n","import { EventEmitter } from \"eventemitter3\";\nimport debug from \"debug\";\nexport class RemoteHeadsSubscriptions extends EventEmitter {\n    // Last known heads and timestamp for each storageId that we know about\n    #syncInfoByDocId = new Map();\n    // Storage IDs we have subscribed to via Repo.subscribeToRemoteHeads\n    #ourSubscriptions = new Set();\n    // Storage IDs other peers have subscribed to by sending us a control message\n    #theirSubscriptions = new Map();\n    // Peers we will always share remote heads with even if they are not subscribed\n    #generousPeers = new Set();\n    // Documents each peer has open, we need this information so we only send remote heads of documents that the peer knows\n    #subscribedDocsByPeer = new Map();\n    #log = debug(\"automerge-repo:remote-heads-subscriptions\");\n    subscribeToRemotes(remotes) {\n        this.#log(\"subscribeToRemotes\", remotes);\n        const remotesToAdd = [];\n        for (const remote of remotes) {\n            if (!this.#ourSubscriptions.has(remote)) {\n                this.#ourSubscriptions.add(remote);\n                remotesToAdd.push(remote);\n            }\n        }\n        if (remotesToAdd.length > 0) {\n            this.emit(\"change-remote-subs\", {\n                add: remotesToAdd,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    unsubscribeFromRemotes(remotes) {\n        this.#log(\"subscribeToRemotes\", remotes);\n        const remotesToRemove = [];\n        for (const remote of remotes) {\n            if (this.#ourSubscriptions.has(remote)) {\n                this.#ourSubscriptions.delete(remote);\n                if (!this.#theirSubscriptions.has(remote)) {\n                    remotesToRemove.push(remote);\n                }\n            }\n        }\n        if (remotesToRemove.length > 0) {\n            this.emit(\"change-remote-subs\", {\n                remove: remotesToRemove,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    handleControlMessage(control) {\n        const remotesToAdd = [];\n        const remotesToRemove = [];\n        const addedRemotesWeKnow = [];\n        this.#log(\"handleControlMessage\", control);\n        if (control.add) {\n            for (const remote of control.add) {\n                let theirSubs = this.#theirSubscriptions.get(remote);\n                if (this.#ourSubscriptions.has(remote) || theirSubs) {\n                    addedRemotesWeKnow.push(remote);\n                }\n                if (!theirSubs) {\n                    theirSubs = new Set();\n                    this.#theirSubscriptions.set(remote, theirSubs);\n                    if (!this.#ourSubscriptions.has(remote)) {\n                        remotesToAdd.push(remote);\n                    }\n                }\n                theirSubs.add(control.senderId);\n            }\n        }\n        if (control.remove) {\n            for (const remote of control.remove) {\n                const theirSubs = this.#theirSubscriptions.get(remote);\n                if (theirSubs) {\n                    theirSubs.delete(control.senderId);\n                    // if no one is subscribed anymore remove remote\n                    if (theirSubs.size == 0 && !this.#ourSubscriptions.has(remote)) {\n                        remotesToRemove.push(remote);\n                    }\n                }\n            }\n        }\n        if (remotesToAdd.length > 0 || remotesToRemove.length > 0) {\n            this.emit(\"change-remote-subs\", {\n                peers: Array.from(this.#generousPeers),\n                add: remotesToAdd,\n                remove: remotesToRemove,\n            });\n        }\n        // send all our stored heads of documents the peer knows for the remotes they've added\n        for (const remote of addedRemotesWeKnow) {\n            const subscribedDocs = this.#subscribedDocsByPeer.get(control.senderId);\n            if (subscribedDocs) {\n                for (const documentId of subscribedDocs) {\n                    const syncInfo = this.#syncInfoByDocId.get(documentId);\n                    if (!syncInfo) {\n                        continue;\n                    }\n                    const syncInfoForRemote = syncInfo.get(remote);\n                    if (syncInfoForRemote) {\n                        this.emit(\"notify-remote-heads\", {\n                            targetId: control.senderId,\n                            documentId,\n                            heads: syncInfoForRemote.lastHeads,\n                            timestamp: syncInfoForRemote.lastSyncTimestamp,\n                            storageId: remote,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /** A peer we are not directly connected to has changed their heads */\n    handleRemoteHeads(msg) {\n        this.#log(\"handleRemoteHeads\", msg);\n        const changedHeads = this.#changedHeads(msg);\n        // Emit a remote-heads-changed event to update local dochandles\n        for (const event of changedHeads) {\n            if (this.#ourSubscriptions.has(event.storageId)) {\n                this.emit(\"remote-heads-changed\", event);\n            }\n        }\n        // Notify generous peers of these changes regardless of if they are subscribed to us\n        for (const event of changedHeads) {\n            for (const peer of this.#generousPeers) {\n                // don't emit event to sender if sender is a generous peer\n                if (peer === msg.senderId) {\n                    continue;\n                }\n                this.emit(\"notify-remote-heads\", {\n                    targetId: peer,\n                    documentId: event.documentId,\n                    heads: event.remoteHeads,\n                    timestamp: event.timestamp,\n                    storageId: event.storageId,\n                });\n            }\n        }\n        // Notify subscribers of these changes\n        for (const event of changedHeads) {\n            const theirSubs = this.#theirSubscriptions.get(event.storageId);\n            if (theirSubs) {\n                for (const peerId of theirSubs) {\n                    if (this.#isPeerSubscribedToDoc(peerId, event.documentId)) {\n                        this.emit(\"notify-remote-heads\", {\n                            targetId: peerId,\n                            documentId: event.documentId,\n                            heads: event.remoteHeads,\n                            timestamp: event.timestamp,\n                            storageId: event.storageId,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /** A peer we are directly connected to has updated their heads */\n    handleImmediateRemoteHeadsChanged(documentId, storageId, heads) {\n        this.#log(\"handleLocalHeadsChanged\", documentId, storageId, heads);\n        const remote = this.#syncInfoByDocId.get(documentId);\n        const timestamp = Date.now();\n        if (!remote) {\n            this.#syncInfoByDocId.set(documentId, new Map([\n                [storageId, { lastSyncTimestamp: timestamp, lastHeads: heads }],\n            ]));\n        }\n        else {\n            const docRemote = remote.get(storageId);\n            if (!docRemote || docRemote.lastSyncTimestamp < Date.now()) {\n                remote.set(storageId, {\n                    lastSyncTimestamp: Date.now(),\n                    lastHeads: heads,\n                });\n            }\n        }\n        const theirSubs = this.#theirSubscriptions.get(storageId);\n        if (theirSubs) {\n            for (const peerId of theirSubs) {\n                if (this.#isPeerSubscribedToDoc(peerId, documentId)) {\n                    this.emit(\"notify-remote-heads\", {\n                        targetId: peerId,\n                        documentId: documentId,\n                        heads: heads,\n                        timestamp: timestamp,\n                        storageId: storageId,\n                    });\n                }\n            }\n        }\n    }\n    addGenerousPeer(peerId) {\n        this.#log(\"addGenerousPeer\", peerId);\n        this.#generousPeers.add(peerId);\n        if (this.#ourSubscriptions.size > 0) {\n            this.emit(\"change-remote-subs\", {\n                add: Array.from(this.#ourSubscriptions),\n                peers: [peerId],\n            });\n        }\n        for (const [documentId, remote] of this.#syncInfoByDocId) {\n            for (const [storageId, { lastHeads, lastSyncTimestamp }] of remote) {\n                this.emit(\"notify-remote-heads\", {\n                    targetId: peerId,\n                    documentId: documentId,\n                    heads: lastHeads,\n                    timestamp: lastSyncTimestamp,\n                    storageId: storageId,\n                });\n            }\n        }\n    }\n    removePeer(peerId) {\n        this.#log(\"removePeer\", peerId);\n        const remotesToRemove = [];\n        this.#generousPeers.delete(peerId);\n        this.#subscribedDocsByPeer.delete(peerId);\n        for (const [storageId, peerIds] of this.#theirSubscriptions) {\n            if (peerIds.has(peerId)) {\n                peerIds.delete(peerId);\n                if (peerIds.size == 0) {\n                    remotesToRemove.push(storageId);\n                    this.#theirSubscriptions.delete(storageId);\n                }\n            }\n        }\n        if (remotesToRemove.length > 0) {\n            this.emit(\"change-remote-subs\", {\n                remove: remotesToRemove,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    subscribePeerToDoc(peerId, documentId) {\n        let subscribedDocs = this.#subscribedDocsByPeer.get(peerId);\n        if (!subscribedDocs) {\n            subscribedDocs = new Set();\n            this.#subscribedDocsByPeer.set(peerId, subscribedDocs);\n        }\n        subscribedDocs.add(documentId);\n        const remoteHeads = this.#syncInfoByDocId.get(documentId);\n        if (remoteHeads) {\n            for (const [storageId, lastHeads] of remoteHeads) {\n                const subscribedPeers = this.#theirSubscriptions.get(storageId);\n                if (subscribedPeers && subscribedPeers.has(peerId)) {\n                    this.emit(\"notify-remote-heads\", {\n                        targetId: peerId,\n                        documentId,\n                        heads: lastHeads.lastHeads,\n                        timestamp: lastHeads.lastSyncTimestamp,\n                        storageId,\n                    });\n                }\n            }\n        }\n    }\n    #isPeerSubscribedToDoc(peerId, documentId) {\n        const subscribedDocs = this.#subscribedDocsByPeer.get(peerId);\n        return subscribedDocs && subscribedDocs.has(documentId);\n    }\n    /** Returns the (document, storageId) pairs which have changed after processing msg */\n    #changedHeads(msg) {\n        const changedHeads = [];\n        const { documentId, newHeads } = msg;\n        for (const [storageId, { heads, timestamp }] of Object.entries(newHeads)) {\n            if (!this.#ourSubscriptions.has(storageId) &&\n                !this.#theirSubscriptions.has(storageId)) {\n                continue;\n            }\n            let remote = this.#syncInfoByDocId.get(documentId);\n            if (!remote) {\n                remote = new Map();\n                this.#syncInfoByDocId.set(documentId, remote);\n            }\n            const docRemote = remote.get(storageId);\n            if (docRemote && docRemote.lastSyncTimestamp >= timestamp) {\n                continue;\n            }\n            else {\n                remote.set(storageId, {\n                    lastSyncTimestamp: timestamp,\n                    lastHeads: heads,\n                });\n                changedHeads.push({\n                    documentId,\n                    storageId: storageId,\n                    remoteHeads: heads,\n                    timestamp,\n                });\n            }\n        }\n        return changedHeads;\n    }\n}\n","/** Throttle\n * Returns a function with a built in throttle timer that runs after `delay` ms.\n *\n * This function differs from a conventional `throttle` in that it ensures the final\n * call will also execute and delays sending the first one until `delay` ms to allow\n * additional work to accumulate.\n *\n * Here's a diagram:\n *\n * calls +----++++++-----++----\n * dlay  ^--v ^--v^--v   ^--v\n * execs ---+----+---+------+--\n *\n * The goal in this design is to create batches of changes without flooding\n * communication or storage systems while still feeling responsive.\n * (By default we communicate at 10hz / every 100ms.)\n *\n * Note that the args go inside the parameter and you should be careful not to\n * recreate the function on each usage. (In React, see useMemo().)\n *\n *\n * Example usage:\n * const callback = throttle((ev) => { doSomethingExpensiveOrOccasional() }, 100)\n * target.addEventListener('frequent-event', callback);\n *\n */\nexport const throttle = (fn, delay) => {\n    let lastCall = Date.now();\n    let wait;\n    let timeout;\n    return function (...args) {\n        wait = lastCall + delay - Date.now();\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            fn(...args);\n            lastCall = Date.now();\n        }, wait);\n    };\n};\n","// TYPE GUARDS\nexport const isRepoMessage = (message) => isSyncMessage(message) ||\n    isEphemeralMessage(message) ||\n    isRequestMessage(message) ||\n    isDocumentUnavailableMessage(message) ||\n    isRemoteSubscriptionControlMessage(message) ||\n    isRemoteHeadsChanged(message);\n// prettier-ignore\nexport const isDocumentUnavailableMessage = (msg) => msg.type === \"doc-unavailable\";\nexport const isRequestMessage = (msg) => msg.type === \"request\";\nexport const isSyncMessage = (msg) => msg.type === \"sync\";\nexport const isEphemeralMessage = (msg) => msg.type === \"ephemeral\";\n// prettier-ignore\nexport const isRemoteSubscriptionControlMessage = (msg) => msg.type === \"remote-subscription-change\";\nexport const isRemoteHeadsChanged = (msg) => msg.type === \"remote-heads-changed\";\n","import debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { isEphemeralMessage, isRepoMessage, } from \"./messages.js\";\nconst getEphemeralMessageSource = (message) => `${message.senderId}:${message.sessionId}`;\nexport class NetworkSubsystem extends EventEmitter {\n    peerId;\n    peerMetadata;\n    #log;\n    #adaptersByPeer = {};\n    #count = 0;\n    #sessionId = Math.random().toString(36).slice(2);\n    #ephemeralSessionCounts = {};\n    adapters = [];\n    constructor(adapters, peerId, peerMetadata) {\n        super();\n        this.peerId = peerId;\n        this.peerMetadata = peerMetadata;\n        this.#log = debug(`automerge-repo:network:${this.peerId}`);\n        adapters.forEach(a => this.addNetworkAdapter(a));\n    }\n    disconnect() {\n        this.adapters.forEach(a => a.disconnect());\n    }\n    reconnect() {\n        this.adapters.forEach(a => a.connect(this.peerId));\n    }\n    addNetworkAdapter(networkAdapter) {\n        this.adapters.push(networkAdapter);\n        networkAdapter.on(\"peer-candidate\", ({ peerId, peerMetadata }) => {\n            this.#log(`peer candidate: ${peerId} `);\n            // TODO: This is where authentication would happen\n            // TODO: on reconnection, this would create problems!\n            // the server would see a reconnection as a late-arriving channel\n            // for an existing peer and decide to ignore it until the connection\n            // times out: turns out my ICE/SIP emulation laziness did not pay off here\n            if (!this.#adaptersByPeer[peerId]) {\n                // TODO: handle losing a server here\n                this.#adaptersByPeer[peerId] = networkAdapter;\n            }\n            this.emit(\"peer\", { peerId, peerMetadata });\n        });\n        networkAdapter.on(\"peer-disconnected\", ({ peerId }) => {\n            this.#log(`peer disconnected: ${peerId} `);\n            delete this.#adaptersByPeer[peerId];\n            this.emit(\"peer-disconnected\", { peerId });\n        });\n        networkAdapter.on(\"message\", msg => {\n            if (!isRepoMessage(msg)) {\n                this.#log(`invalid message: ${JSON.stringify(msg)}`);\n                return;\n            }\n            this.#log(`message from ${msg.senderId}`);\n            if (isEphemeralMessage(msg)) {\n                const source = getEphemeralMessageSource(msg);\n                if (this.#ephemeralSessionCounts[source] === undefined ||\n                    msg.count > this.#ephemeralSessionCounts[source]) {\n                    this.#ephemeralSessionCounts[source] = msg.count;\n                    this.emit(\"message\", msg);\n                }\n                return;\n            }\n            this.emit(\"message\", msg);\n        });\n        networkAdapter.on(\"close\", () => {\n            this.#log(\"adapter closed\");\n            Object.entries(this.#adaptersByPeer).forEach(([peerId, other]) => {\n                if (other === networkAdapter) {\n                    delete this.#adaptersByPeer[peerId];\n                }\n            });\n            this.adapters = this.adapters.filter(a => a !== networkAdapter);\n        });\n        this.peerMetadata\n            .then(peerMetadata => {\n            networkAdapter.connect(this.peerId, peerMetadata);\n        })\n            .catch(err => {\n            this.#log(\"error connecting to network\", err);\n        });\n    }\n    // TODO: this probably introduces a race condition for the ready event\n    // but I plan to refactor that as part of this branch in another patch\n    removeNetworkAdapter(networkAdapter) {\n        this.adapters = this.adapters.filter(a => a !== networkAdapter);\n        networkAdapter.disconnect();\n    }\n    send(message) {\n        const peer = this.#adaptersByPeer[message.targetId];\n        if (!peer) {\n            this.#log(`Tried to send message but peer not found: ${message.targetId}`);\n            return;\n        }\n        /** Messages come in without a senderId and other required information; this is where we make\n         * sure they have everything they need.\n         */\n        const prepareMessage = (message) => {\n            if (message.type === \"ephemeral\") {\n                if (\"count\" in message) {\n                    // existing ephemeral message from another peer; pass on without changes\n                    return message;\n                }\n                else {\n                    // new ephemeral message from us; add our senderId as well as a counter and session id\n                    return {\n                        ...message,\n                        count: ++this.#count,\n                        sessionId: this.#sessionId,\n                        senderId: this.peerId,\n                    };\n                }\n            }\n            else {\n                // other message type; just add our senderId\n                return {\n                    ...message,\n                    senderId: this.peerId,\n                };\n            }\n        };\n        const outbound = prepareMessage(message);\n        this.#log(\"sending message %o\", outbound);\n        peer.send(outbound);\n    }\n    isReady = () => {\n        return this.adapters.every(a => a.isReady());\n    };\n    whenReady = async () => {\n        return Promise.all(this.adapters.map(a => a.whenReady()));\n    };\n}\n","export function mergeArrays(myArrays) {\n    // Get the total length of all arrays.\n    let length = 0;\n    myArrays.forEach(item => {\n        length += item.length;\n    });\n    // Create a new array with total length and merge all source arrays.\n    const mergedArray = new Uint8Array(length);\n    let offset = 0;\n    myArrays.forEach(item => {\n        mergedArray.set(item, offset);\n        offset += item.length;\n    });\n    return mergedArray;\n}\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |\n                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^\n                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^\n                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len < dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","import * as sha256 from \"fast-sha256\";\nimport { mergeArrays } from \"../helpers/mergeArrays.js\";\nexport function keyHash(binary) {\n    // calculate hash\n    const hash = sha256.hash(binary);\n    return bufferToHexString(hash);\n}\nexport function headsHash(heads) {\n    const encoder = new TextEncoder();\n    const headsbinary = mergeArrays(heads.map((h) => encoder.encode(h)));\n    return keyHash(headsbinary);\n}\nfunction bufferToHexString(data) {\n    return Array.from(data, byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n","import { next as A } from \"@automerge/automerge/slim\";\nimport debug from \"debug\";\nimport { headsAreSame } from \"../helpers/headsAreSame.js\";\nimport { mergeArrays } from \"../helpers/mergeArrays.js\";\nimport { keyHash, headsHash } from \"./keyHash.js\";\nimport * as Uuid from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { encodeHeads } from \"../AutomergeUrl.js\";\n/**\n * The storage subsystem is responsible for saving and loading Automerge documents to and from\n * storage adapter. It also provides a generic key/value storage interface for other uses.\n */\nexport class StorageSubsystem extends EventEmitter {\n    /** The storage adapter to use for saving and loading documents */\n    #storageAdapter;\n    /** Record of the latest heads we've loaded or saved for each document  */\n    #storedHeads = new Map();\n    /** Metadata on the chunks we've already loaded for each document */\n    #chunkInfos = new Map();\n    /** Flag to avoid compacting when a compaction is already underway */\n    #compacting = false;\n    #log = debug(`automerge-repo:storage-subsystem`);\n    constructor(storageAdapter) {\n        super();\n        this.#storageAdapter = storageAdapter;\n    }\n    async id() {\n        const storedId = await this.#storageAdapter.load([\"storage-adapter-id\"]);\n        let id;\n        if (storedId) {\n            id = new TextDecoder().decode(storedId);\n        }\n        else {\n            id = Uuid.v4();\n            await this.#storageAdapter.save([\"storage-adapter-id\"], new TextEncoder().encode(id));\n        }\n        return id;\n    }\n    // ARBITRARY KEY/VALUE STORAGE\n    // The `load`, `save`, and `remove` methods are for generic key/value storage, as opposed to\n    // Automerge documents. For example, they're used by the LocalFirstAuthProvider to persist the\n    // encrypted team graph that encodes group membership and permissions.\n    //\n    // The namespace parameter is to prevent collisions with other users of the storage subsystem.\n    // Typically this will be the name of the plug-in, adapter, or other system that is using it. For\n    // example, the LocalFirstAuthProvider uses the namespace `LocalFirstAuthProvider`.\n    /** Loads a value from storage. */\n    async load(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */\n    key) {\n        const storageKey = [namespace, key];\n        return await this.#storageAdapter.load(storageKey);\n    }\n    /** Saves a value in storage. */\n    async save(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */\n    key, \n    /** Data to save, as a binary blob. */\n    data) {\n        const storageKey = [namespace, key];\n        await this.#storageAdapter.save(storageKey, data);\n    }\n    /** Removes a value from storage. */\n    async remove(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to remove. Typically a UUID or other unique identifier, but could be any string. */\n    key) {\n        const storageKey = [namespace, key];\n        await this.#storageAdapter.remove(storageKey);\n    }\n    // AUTOMERGE DOCUMENT STORAGE\n    /**\n     * Loads and combines document chunks from storage, with snapshots first.\n     */\n    async loadDocData(documentId) {\n        // Load snapshots first\n        const snapshotChunks = await this.#storageAdapter.loadRange([\n            documentId,\n            \"snapshot\",\n        ]);\n        const incrementalChunks = await this.#storageAdapter.loadRange([\n            documentId,\n            \"incremental\",\n        ]);\n        const binaries = [];\n        const chunkInfos = [];\n        // Process snapshots first\n        for (const chunk of snapshotChunks) {\n            if (chunk.data === undefined)\n                continue;\n            chunkInfos.push({\n                key: chunk.key,\n                type: \"snapshot\",\n                size: chunk.data.length,\n            });\n            binaries.push(chunk.data);\n        }\n        // Then process incrementals\n        for (const chunk of incrementalChunks) {\n            if (chunk.data === undefined)\n                continue;\n            chunkInfos.push({\n                key: chunk.key,\n                type: \"incremental\",\n                size: chunk.data.length,\n            });\n            binaries.push(chunk.data);\n        }\n        // Store chunk infos for future reference\n        this.#chunkInfos.set(documentId, chunkInfos);\n        // If no chunks were found, return null\n        if (binaries.length === 0) {\n            return null;\n        }\n        // Merge the chunks into a single binary\n        return mergeArrays(binaries);\n    }\n    /**\n     * Loads the Automerge document with the given ID from storage.\n     */\n    async loadDoc(documentId) {\n        // Load and combine chunks\n        const binary = await this.loadDocData(documentId);\n        if (!binary)\n            return null;\n        // Load into an Automerge document\n        const start = performance.now();\n        const newDoc = A.loadIncremental(A.init(), binary);\n        const end = performance.now();\n        this.emit(\"document-loaded\", {\n            documentId,\n            durationMillis: end - start,\n            ...A.stats(newDoc),\n        });\n        // Record the latest heads for the document\n        this.#storedHeads.set(documentId, A.getHeads(newDoc));\n        return newDoc;\n    }\n    /**\n     * Saves the provided Automerge document to storage.\n     *\n     * @remarks\n     * Under the hood this makes incremental saves until the incremental size is greater than the\n     * snapshot size, at which point the document is compacted into a single snapshot.\n     */\n    async saveDoc(documentId, doc) {\n        // Don't bother saving if the document hasn't changed\n        if (!this.#shouldSave(documentId, doc))\n            return;\n        const sourceChunks = this.#chunkInfos.get(documentId) ?? [];\n        if (this.#shouldCompact(sourceChunks)) {\n            await this.#saveTotal(documentId, doc, sourceChunks);\n        }\n        else {\n            await this.#saveIncremental(documentId, doc);\n        }\n        this.#storedHeads.set(documentId, A.getHeads(doc));\n    }\n    /**\n     * Removes the Automerge document with the given ID from storage\n     */\n    async removeDoc(documentId) {\n        await this.#storageAdapter.removeRange([documentId, \"snapshot\"]);\n        await this.#storageAdapter.removeRange([documentId, \"incremental\"]);\n        await this.#storageAdapter.removeRange([documentId, \"sync-state\"]);\n    }\n    /**\n     * Saves just the incremental changes since the last save.\n     */\n    async #saveIncremental(documentId, doc) {\n        const binary = A.saveSince(doc, this.#storedHeads.get(documentId) ?? []);\n        if (binary && binary.length > 0) {\n            const key = [documentId, \"incremental\", keyHash(binary)];\n            this.#log(`Saving incremental ${key} for document ${documentId}`);\n            await this.#storageAdapter.save(key, binary);\n            if (!this.#chunkInfos.has(documentId)) {\n                this.#chunkInfos.set(documentId, []);\n            }\n            this.#chunkInfos.get(documentId).push({\n                key,\n                type: \"incremental\",\n                size: binary.length,\n            });\n            this.#storedHeads.set(documentId, A.getHeads(doc));\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Compacts the document storage into a single shapshot.\n     */\n    async #saveTotal(documentId, doc, sourceChunks) {\n        this.#compacting = true;\n        const binary = A.save(doc);\n        const snapshotHash = headsHash(A.getHeads(doc));\n        const key = [documentId, \"snapshot\", snapshotHash];\n        const oldKeys = new Set(sourceChunks.map(c => c.key).filter(k => k[2] !== snapshotHash));\n        this.#log(`Saving snapshot ${key} for document ${documentId}`);\n        this.#log(`deleting old chunks ${Array.from(oldKeys)}`);\n        await this.#storageAdapter.save(key, binary);\n        for (const key of oldKeys) {\n            await this.#storageAdapter.remove(key);\n        }\n        const newChunkInfos = this.#chunkInfos.get(documentId)?.filter(c => !oldKeys.has(c.key)) ?? [];\n        newChunkInfos.push({ key, type: \"snapshot\", size: binary.length });\n        this.#chunkInfos.set(documentId, newChunkInfos);\n        this.#compacting = false;\n    }\n    async loadSyncState(documentId, storageId) {\n        const key = [documentId, \"sync-state\", storageId];\n        try {\n            const loaded = await this.#storageAdapter.load(key);\n            return loaded ? A.decodeSyncState(loaded) : undefined;\n        }\n        catch (e) {\n            this.#log(`Error loading sync state for ${documentId} from ${storageId}`);\n            return undefined;\n        }\n    }\n    async saveSyncState(documentId, storageId, syncState) {\n        const key = [documentId, \"sync-state\", storageId];\n        await this.#storageAdapter.save(key, A.encodeSyncState(syncState));\n    }\n    /**\n     * Returns true if the document has changed since the last time it was saved.\n     */\n    #shouldSave(documentId, doc) {\n        const oldHeads = this.#storedHeads.get(documentId);\n        if (!oldHeads) {\n            // we haven't saved this document before\n            return true;\n        }\n        const newHeads = A.getHeads(doc);\n        if (headsAreSame(encodeHeads(newHeads), encodeHeads(oldHeads))) {\n            // the document hasn't changed\n            return false;\n        }\n        return true; // the document has changed\n    }\n    /**\n     * We only compact if the incremental size is greater than the snapshot size.\n     */\n    #shouldCompact(sourceChunks) {\n        if (this.#compacting)\n            return false;\n        let snapshotSize = 0;\n        let incrementalSize = 0;\n        for (const chunk of sourceChunks) {\n            if (chunk.type === \"snapshot\") {\n                snapshotSize += chunk.size;\n            }\n            else {\n                incrementalSize += chunk.size;\n            }\n        }\n        // if the file is currently small, don't worry, just compact\n        // this might seem a bit arbitrary (1k is arbitrary) but is designed to ensure compaction\n        // for documents with only a single large change on top of an empty (or nearly empty) document\n        // for example: imported NPM modules, images, etc.\n        // if we have even more incrementals (so far) than the snapshot, compact\n        return snapshotSize < 1024 || incrementalSize >= snapshotSize;\n    }\n}\n","import { EventEmitter } from \"eventemitter3\";\nexport class Synchronizer extends EventEmitter {\n}\n","import { next as A } from \"@automerge/automerge/slim\";\nimport { decode } from \"cbor-x\";\nimport debug from \"debug\";\nimport { READY, REQUESTING, UNAVAILABLE, } from \"../DocHandle.js\";\nimport { isRequestMessage, } from \"../network/messages.js\";\nimport { Synchronizer } from \"./Synchronizer.js\";\nimport { throttle } from \"../helpers/throttle.js\";\n/**\n * DocSynchronizer takes a handle to an Automerge document, and receives & dispatches sync messages\n * to bring it inline with all other peers' versions.\n */\nexport class DocSynchronizer extends Synchronizer {\n    #log;\n    syncDebounceRate = 100;\n    /** Active peers */\n    #peers = [];\n    #pendingSyncStateCallbacks = {};\n    #peerDocumentStatuses = {};\n    /** Sync state for each peer we've communicated with (including inactive peers) */\n    #syncStates = {};\n    #pendingSyncMessages = [];\n    // We keep this around at least in part for debugging.\n    // eslint-disable-next-line no-unused-private-class-members\n    #peerId;\n    #syncStarted = false;\n    #handle;\n    #onLoadSyncState;\n    constructor({ handle, peerId, onLoadSyncState }) {\n        super();\n        this.#peerId = peerId;\n        this.#handle = handle;\n        this.#onLoadSyncState =\n            onLoadSyncState ?? (() => Promise.resolve(undefined));\n        const docId = handle.documentId.slice(0, 5);\n        this.#log = debug(`automerge-repo:docsync:${docId}`);\n        handle.on(\"change\", throttle(() => this.#syncWithPeers(), this.syncDebounceRate));\n        handle.on(\"ephemeral-message-outbound\", payload => this.#broadcastToPeers(payload));\n        // Process pending sync messages immediately after the handle becomes ready.\n        void (async () => {\n            this.#processAllPendingSyncMessages();\n        })();\n    }\n    get peerStates() {\n        return this.#peerDocumentStatuses;\n    }\n    get documentId() {\n        return this.#handle.documentId;\n    }\n    /// PRIVATE\n    async #syncWithPeers() {\n        try {\n            await this.#handle.whenReady();\n            const doc = this.#handle.doc(); // XXX THIS ONE IS WEIRD\n            this.#peers.forEach(peerId => this.#sendSyncMessage(peerId, doc));\n        }\n        catch (e) {\n            console.log(\"sync with peers threw an exception\");\n        }\n    }\n    async #broadcastToPeers({ data, }) {\n        this.#log(`broadcastToPeers`, this.#peers);\n        this.#peers.forEach(peerId => this.#sendEphemeralMessage(peerId, data));\n    }\n    #sendEphemeralMessage(peerId, data) {\n        this.#log(`sendEphemeralMessage ->${peerId}`);\n        const message = {\n            type: \"ephemeral\",\n            targetId: peerId,\n            documentId: this.#handle.documentId,\n            data,\n        };\n        this.emit(\"message\", message);\n    }\n    #withSyncState(peerId, callback) {\n        this.#addPeer(peerId);\n        if (!(peerId in this.#peerDocumentStatuses)) {\n            this.#peerDocumentStatuses[peerId] = \"unknown\";\n        }\n        const syncState = this.#syncStates[peerId];\n        if (syncState) {\n            callback(syncState);\n            return;\n        }\n        let pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];\n        if (!pendingCallbacks) {\n            this.#onLoadSyncState(peerId)\n                .then(syncState => {\n                this.#initSyncState(peerId, syncState ?? A.initSyncState());\n            })\n                .catch(err => {\n                this.#log(`Error loading sync state for ${peerId}: ${err}`);\n            });\n            pendingCallbacks = this.#pendingSyncStateCallbacks[peerId] = [];\n        }\n        pendingCallbacks.push(callback);\n    }\n    #addPeer(peerId) {\n        if (!this.#peers.includes(peerId)) {\n            this.#peers.push(peerId);\n            this.emit(\"open-doc\", { documentId: this.documentId, peerId });\n        }\n    }\n    #initSyncState(peerId, syncState) {\n        const pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];\n        if (pendingCallbacks) {\n            for (const callback of pendingCallbacks) {\n                callback(syncState);\n            }\n        }\n        delete this.#pendingSyncStateCallbacks[peerId];\n        this.#syncStates[peerId] = syncState;\n    }\n    #setSyncState(peerId, syncState) {\n        this.#syncStates[peerId] = syncState;\n        this.emit(\"sync-state\", {\n            peerId,\n            syncState,\n            documentId: this.#handle.documentId,\n        });\n    }\n    #sendSyncMessage(peerId, doc) {\n        this.#log(`sendSyncMessage ->${peerId}`);\n        this.#withSyncState(peerId, syncState => {\n            const [newSyncState, message] = A.generateSyncMessage(doc, syncState);\n            if (message) {\n                this.#setSyncState(peerId, newSyncState);\n                const isNew = A.getHeads(doc).length === 0;\n                if (!this.#handle.isReady() &&\n                    isNew &&\n                    newSyncState.sharedHeads.length === 0 &&\n                    !Object.values(this.#peerDocumentStatuses).includes(\"has\") &&\n                    this.#peerDocumentStatuses[peerId] === \"unknown\") {\n                    // we don't have the document (or access to it), so we request it\n                    this.emit(\"message\", {\n                        type: \"request\",\n                        targetId: peerId,\n                        documentId: this.#handle.documentId,\n                        data: message,\n                    });\n                }\n                else {\n                    this.emit(\"message\", {\n                        type: \"sync\",\n                        targetId: peerId,\n                        data: message,\n                        documentId: this.#handle.documentId,\n                    });\n                }\n                // if we have sent heads, then the peer now has or will have the document\n                if (!isNew) {\n                    this.#peerDocumentStatuses[peerId] = \"has\";\n                }\n            }\n        });\n    }\n    /// PUBLIC\n    hasPeer(peerId) {\n        return this.#peers.includes(peerId);\n    }\n    async beginSync(peerIds) {\n        void this.#handle\n            .whenReady([READY, REQUESTING, UNAVAILABLE])\n            .then(() => {\n            this.#syncStarted = true;\n            this.#checkDocUnavailable();\n        })\n            .catch(e => {\n            console.log(\"caught whenready\", e);\n            this.#syncStarted = true;\n            this.#checkDocUnavailable();\n        });\n        const peersWithDocument = this.#peers.some(peerId => {\n            return this.#peerDocumentStatuses[peerId] == \"has\";\n        });\n        if (peersWithDocument) {\n            await this.#handle.whenReady();\n        }\n        peerIds.forEach(peerId => {\n            this.#withSyncState(peerId, syncState => {\n                // HACK: if we have a sync state already, we round-trip it through the encoding system to make\n                // sure state is preserved. This prevents an infinite loop caused by failed attempts to send\n                // messages during disconnection.\n                // TODO: cover that case with a test and remove this hack\n                const reparsedSyncState = A.decodeSyncState(A.encodeSyncState(syncState));\n                this.#setSyncState(peerId, reparsedSyncState);\n                // At this point if we don't have anything in our storage, we need to use an empty doc to sync\n                // with; but we don't want to surface that state to the front end\n                this.#handle\n                    .whenReady([READY, REQUESTING, UNAVAILABLE])\n                    .then(() => {\n                    const doc = this.#handle.isReady()\n                        ? this.#handle.doc()\n                        : A.init();\n                    const noPeersWithDocument = peerIds.every(peerId => this.#peerDocumentStatuses[peerId] in [\"unavailable\", \"wants\"]);\n                    const wasUnavailable = doc === undefined;\n                    if (wasUnavailable && noPeersWithDocument) {\n                        return;\n                    }\n                    // If the doc is unavailable we still need a blank document to generate\n                    // the sync message from\n                    this.#sendSyncMessage(peerId, doc ?? A.init());\n                })\n                    .catch(err => {\n                    this.#log(`Error loading doc for ${peerId}: ${err}`);\n                });\n            });\n        });\n    }\n    endSync(peerId) {\n        this.#log(`removing peer ${peerId}`);\n        this.#peers = this.#peers.filter(p => p !== peerId);\n        delete this.#peerDocumentStatuses[peerId];\n        this.#checkDocUnavailable();\n    }\n    receiveMessage(message) {\n        switch (message.type) {\n            case \"sync\":\n            case \"request\":\n                this.receiveSyncMessage(message);\n                break;\n            case \"ephemeral\":\n                this.receiveEphemeralMessage(message);\n                break;\n            case \"doc-unavailable\":\n                this.#peerDocumentStatuses[message.senderId] = \"unavailable\";\n                this.#checkDocUnavailable();\n                break;\n            default:\n                throw new Error(`unknown message type: ${message}`);\n        }\n    }\n    receiveEphemeralMessage(message) {\n        if (message.documentId !== this.#handle.documentId)\n            throw new Error(`channelId doesn't match documentId`);\n        const { senderId, data } = message;\n        const contents = decode(new Uint8Array(data));\n        this.#handle.emit(\"ephemeral-message\", {\n            handle: this.#handle,\n            senderId,\n            message: contents,\n        });\n        this.#peers.forEach(peerId => {\n            if (peerId === senderId)\n                return;\n            this.emit(\"message\", {\n                ...message,\n                targetId: peerId,\n            });\n        });\n    }\n    receiveSyncMessage(message) {\n        if (message.documentId !== this.#handle.documentId)\n            throw new Error(`channelId doesn't match documentId`);\n        // We need to block receiving the syncMessages until we've checked local storage\n        if (!this.#handle.inState([READY, REQUESTING, UNAVAILABLE])) {\n            this.#pendingSyncMessages.push({ message, received: new Date() });\n            return;\n        }\n        this.#processAllPendingSyncMessages();\n        this.#processSyncMessage(message);\n    }\n    #processSyncMessage(message) {\n        if (isRequestMessage(message)) {\n            this.#peerDocumentStatuses[message.senderId] = \"wants\";\n        }\n        this.#checkDocUnavailable();\n        // if the message has heads, then the peer has the document\n        if (A.decodeSyncMessage(message.data).heads.length > 0) {\n            this.#peerDocumentStatuses[message.senderId] = \"has\";\n        }\n        this.#withSyncState(message.senderId, syncState => {\n            this.#handle.update(doc => {\n                const start = performance.now();\n                const [newDoc, newSyncState] = A.receiveSyncMessage(doc, syncState, message.data);\n                const end = performance.now();\n                this.emit(\"metrics\", {\n                    type: \"receive-sync-message\",\n                    documentId: this.#handle.documentId,\n                    durationMillis: end - start,\n                    ...A.stats(doc),\n                });\n                this.#setSyncState(message.senderId, newSyncState);\n                // respond to just this peer (as required)\n                this.#sendSyncMessage(message.senderId, doc);\n                return newDoc;\n            });\n            this.#checkDocUnavailable();\n        });\n    }\n    #checkDocUnavailable() {\n        // if we know none of the peers have the document, tell all our peers that we don't either\n        if (this.#syncStarted &&\n            this.#handle.inState([REQUESTING, UNAVAILABLE]) &&\n            this.#peers.every(peerId => this.#peerDocumentStatuses[peerId] === \"unavailable\" ||\n                this.#peerDocumentStatuses[peerId] === \"wants\")) {\n            this.#peers\n                .filter(peerId => this.#peerDocumentStatuses[peerId] === \"wants\")\n                .forEach(peerId => {\n                // Transition the peer to unavailable so that we don't send it a doc-unavailable\n                // message every time we run #checkDocUnavailable\n                this.#peerDocumentStatuses[peerId] = \"unavailable\";\n                const message = {\n                    type: \"doc-unavailable\",\n                    documentId: this.#handle.documentId,\n                    targetId: peerId,\n                };\n                this.emit(\"message\", message);\n            });\n            this.#handle.unavailable();\n        }\n    }\n    #processAllPendingSyncMessages() {\n        for (const message of this.#pendingSyncMessages) {\n            this.#processSyncMessage(message.message);\n        }\n        this.#pendingSyncMessages = [];\n    }\n    metrics() {\n        return {\n            peers: this.#peers,\n            size: this.#handle.metrics(),\n        };\n    }\n}\n","import debug from \"debug\";\nimport { parseAutomergeUrl } from \"../AutomergeUrl.js\";\nimport { DocSynchronizer } from \"./DocSynchronizer.js\";\nimport { Synchronizer } from \"./Synchronizer.js\";\nconst log = debug(\"automerge-repo:collectionsync\");\n/** A CollectionSynchronizer is responsible for synchronizing a DocCollection with peers. */\nexport class CollectionSynchronizer extends Synchronizer {\n    repo;\n    /** The set of peers we are connected with */\n    #peers = new Set();\n    /** A map of documentIds to their synchronizers */\n    /** @hidden */\n    docSynchronizers = {};\n    /** Used to determine if the document is know to the Collection and a synchronizer exists or is being set up */\n    #docSetUp = {};\n    #denylist;\n    constructor(repo, denylist = []) {\n        super();\n        this.repo = repo;\n        this.#denylist = denylist.map(url => parseAutomergeUrl(url).documentId);\n    }\n    /** Returns a synchronizer for the given document, creating one if it doesn't already exist.  */\n    #fetchDocSynchronizer(handle) {\n        if (!this.docSynchronizers[handle.documentId]) {\n            this.docSynchronizers[handle.documentId] =\n                this.#initDocSynchronizer(handle);\n        }\n        return this.docSynchronizers[handle.documentId];\n    }\n    /** Creates a new docSynchronizer and sets it up to propagate messages */\n    #initDocSynchronizer(handle) {\n        const docSynchronizer = new DocSynchronizer({\n            handle,\n            peerId: this.repo.networkSubsystem.peerId,\n            onLoadSyncState: async (peerId) => {\n                if (!this.repo.storageSubsystem) {\n                    return;\n                }\n                const { storageId, isEphemeral } = this.repo.peerMetadataByPeerId[peerId] || {};\n                if (!storageId || isEphemeral) {\n                    return;\n                }\n                return this.repo.storageSubsystem.loadSyncState(handle.documentId, storageId);\n            },\n        });\n        docSynchronizer.on(\"message\", event => this.emit(\"message\", event));\n        docSynchronizer.on(\"open-doc\", event => this.emit(\"open-doc\", event));\n        docSynchronizer.on(\"sync-state\", event => this.emit(\"sync-state\", event));\n        docSynchronizer.on(\"metrics\", event => this.emit(\"metrics\", event));\n        return docSynchronizer;\n    }\n    /** returns an array of peerIds that we share this document generously with */\n    async #documentGenerousPeers(documentId) {\n        const peers = Array.from(this.#peers);\n        const generousPeers = [];\n        for (const peerId of peers) {\n            const okToShare = await this.repo.sharePolicy(peerId, documentId);\n            if (okToShare)\n                generousPeers.push(peerId);\n        }\n        return generousPeers;\n    }\n    // PUBLIC\n    /**\n     * When we receive a sync message for a document we haven't got in memory, we\n     * register it with the repo and start synchronizing\n     */\n    async receiveMessage(message) {\n        log(`onSyncMessage: ${message.senderId}, ${message.documentId}, ${\"data\" in message ? message.data.byteLength + \"bytes\" : \"\"}`);\n        const documentId = message.documentId;\n        if (!documentId) {\n            throw new Error(\"received a message with an invalid documentId\");\n        }\n        if (this.#denylist.includes(documentId)) {\n            this.emit(\"metrics\", {\n                type: \"doc-denied\",\n                documentId,\n            });\n            this.emit(\"message\", {\n                type: \"doc-unavailable\",\n                documentId,\n                targetId: message.senderId,\n            });\n            return;\n        }\n        this.#docSetUp[documentId] = true;\n        const handle = await this.repo.find(documentId, {\n            allowableStates: [\"ready\", \"unavailable\", \"requesting\"],\n        });\n        const docSynchronizer = this.#fetchDocSynchronizer(handle);\n        docSynchronizer.receiveMessage(message);\n        // Initiate sync with any new peers\n        const peers = await this.#documentGenerousPeers(documentId);\n        void docSynchronizer.beginSync(peers.filter(peerId => !docSynchronizer.hasPeer(peerId)));\n    }\n    /**\n     * Starts synchronizing the given document with all peers that we share it generously with.\n     */\n    addDocument(handle) {\n        // HACK: this is a hack to prevent us from adding the same document twice\n        if (this.#docSetUp[handle.documentId]) {\n            return;\n        }\n        const docSynchronizer = this.#fetchDocSynchronizer(handle);\n        void this.#documentGenerousPeers(handle.documentId).then(peers => {\n            void docSynchronizer.beginSync(peers);\n        });\n    }\n    /** Removes a document and stops synchronizing them */\n    removeDocument(documentId) {\n        log(`removing document ${documentId}`);\n        const docSynchronizer = this.docSynchronizers[documentId];\n        if (docSynchronizer !== undefined) {\n            this.peers.forEach(peerId => docSynchronizer.endSync(peerId));\n        }\n        delete this.docSynchronizers[documentId];\n        delete this.#docSetUp[documentId];\n    }\n    /** Adds a peer and maybe starts synchronizing with them */\n    addPeer(peerId) {\n        log(`adding ${peerId} & synchronizing with them`);\n        if (this.#peers.has(peerId)) {\n            return;\n        }\n        this.#peers.add(peerId);\n        for (const docSynchronizer of Object.values(this.docSynchronizers)) {\n            const { documentId } = docSynchronizer;\n            void this.repo.sharePolicy(peerId, documentId).then(okToShare => {\n                if (okToShare)\n                    void docSynchronizer.beginSync([peerId]);\n            });\n        }\n    }\n    /** Removes a peer and stops synchronizing with them */\n    removePeer(peerId) {\n        log(`removing peer ${peerId}`);\n        this.#peers.delete(peerId);\n        for (const docSynchronizer of Object.values(this.docSynchronizers)) {\n            docSynchronizer.endSync(peerId);\n        }\n    }\n    /** Returns a list of all connected peer ids */\n    get peers() {\n        return Array.from(this.#peers);\n    }\n    metrics() {\n        return Object.fromEntries(Object.entries(this.docSynchronizers).map(([documentId, synchronizer]) => {\n            return [documentId, synchronizer.metrics()];\n        }));\n    }\n}\n","/**\n * Wraps a Promise and causes it to reject when the signal is aborted.\n *\n * @remarks\n * This utility wraps a Promise and rejects when the provided AbortSignal is aborted.\n * It's designed to make Promise awaits abortable.\n *\n * @example\n * ```typescript\n * const controller = new AbortController();\n *\n * try {\n *   const result = await abortable(fetch('https://api.example.com/data'), controller.signal);\n *   // Meanwhile, to abort in concurrent code before the above line returns: controller.abort();\n * } catch (err) {\n *   if (err.name === 'AbortError') {\n *     console.log('The operation was aborted');\n *   }\n * }\n *\n * ```\n *\n * @param p - A Promise to wrap\n * @param signal - An AbortSignal that can be used to abort the operation\n * @returns A wrapper Promise that rejects with AbortError if the signal is aborted\n * before the promise p settles, and settles as p settles otherwise\n * @throws {DOMException} With name \"AbortError\" if aborted before p settles\n */\nexport function abortable(p, signal) {\n    let settled = false;\n    return new Promise((resolve, reject) => {\n        signal?.addEventListener(\"abort\", () => {\n            if (!settled) {\n                reject(new DOMException(\"Operation aborted\", \"AbortError\"));\n            }\n        }, { once: true });\n        p.then(result => {\n            resolve(result);\n        })\n            .catch(error => {\n            reject(error);\n        })\n            .finally(() => {\n            settled = true;\n        });\n    });\n}\n","import { next as Automerge } from \"@automerge/automerge/slim\";\nimport debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { encodeHeads, generateAutomergeUrl, interpretAsDocumentId, isValidAutomergeUrl, parseAutomergeUrl, } from \"./AutomergeUrl.js\";\nimport { DELETED, DocHandle, READY, UNAVAILABLE, UNLOADED, } from \"./DocHandle.js\";\nimport { RemoteHeadsSubscriptions } from \"./RemoteHeadsSubscriptions.js\";\nimport { headsAreSame } from \"./helpers/headsAreSame.js\";\nimport { throttle } from \"./helpers/throttle.js\";\nimport { NetworkSubsystem } from \"./network/NetworkSubsystem.js\";\nimport { StorageSubsystem } from \"./storage/StorageSubsystem.js\";\nimport { CollectionSynchronizer } from \"./synchronizer/CollectionSynchronizer.js\";\nimport { abortable } from \"./helpers/abortable.js\";\nfunction randomPeerId() {\n    return (\"peer-\" + Math.random().toString(36).slice(4));\n}\n/** A Repo is a collection of documents with networking, syncing, and storage capabilities. */\n/** The `Repo` is the main entry point of this library\n *\n * @remarks\n * To construct a `Repo` you will need an {@link StorageAdapter} and one or\n * more {@link NetworkAdapter}s. Once you have a `Repo` you can use it to\n * obtain {@link DocHandle}s.\n */\nexport class Repo extends EventEmitter {\n    #log;\n    /** @hidden */\n    networkSubsystem;\n    /** @hidden */\n    storageSubsystem;\n    /** @hidden */\n    #saveDebounceRate;\n    /** @hidden */\n    #saveFn;\n    #handleCache = {};\n    /** @hidden */\n    synchronizer;\n    /** By default, we share generously with all peers. */\n    /** @hidden */\n    sharePolicy = async () => true;\n    /** maps peer id to to persistence information (storageId, isEphemeral), access by collection synchronizer  */\n    /** @hidden */\n    peerMetadataByPeerId = {};\n    #remoteHeadsSubscriptions = new RemoteHeadsSubscriptions();\n    #remoteHeadsGossipingEnabled = false;\n    #progressCache = {};\n    constructor({ storage, network = [], peerId = randomPeerId(), sharePolicy, isEphemeral = storage === undefined, enableRemoteHeadsGossiping = false, denylist = [], saveDebounceRate = 100, } = {}) {\n        super();\n        this.#remoteHeadsGossipingEnabled = enableRemoteHeadsGossiping;\n        this.#log = debug(`automerge-repo:repo`);\n        this.sharePolicy = sharePolicy ?? this.sharePolicy;\n        this.on(\"delete-document\", ({ documentId }) => {\n            this.synchronizer.removeDocument(documentId);\n            if (storageSubsystem) {\n                storageSubsystem.removeDoc(documentId).catch(err => {\n                    this.#log(\"error deleting document\", { documentId, err });\n                });\n            }\n        });\n        // SYNCHRONIZER\n        // The synchronizer uses the network subsystem to keep documents in sync with peers.\n        this.synchronizer = new CollectionSynchronizer(this, denylist);\n        // When the synchronizer emits messages, send them to peers\n        this.synchronizer.on(\"message\", message => {\n            this.#log(`sending ${message.type} message to ${message.targetId}`);\n            networkSubsystem.send(message);\n        });\n        // Forward metrics from doc synchronizers\n        this.synchronizer.on(\"metrics\", event => this.emit(\"doc-metrics\", event));\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.synchronizer.on(\"open-doc\", ({ peerId, documentId }) => {\n                this.#remoteHeadsSubscriptions.subscribePeerToDoc(peerId, documentId);\n            });\n        }\n        // STORAGE\n        // The storage subsystem has access to some form of persistence, and deals with save and loading documents.\n        const storageSubsystem = storage ? new StorageSubsystem(storage) : undefined;\n        if (storageSubsystem) {\n            storageSubsystem.on(\"document-loaded\", event => this.emit(\"doc-metrics\", { type: \"doc-loaded\", ...event }));\n        }\n        this.storageSubsystem = storageSubsystem;\n        this.#saveDebounceRate = saveDebounceRate;\n        if (this.storageSubsystem) {\n            const saveFn = ({ handle, doc }) => {\n                void this.storageSubsystem.saveDoc(handle.documentId, doc);\n            };\n            // Save no more often than saveDebounceRate.\n            this.#saveFn = throttle(saveFn, this.#saveDebounceRate);\n        }\n        else {\n            this.#saveFn = () => { };\n        }\n        // NETWORK\n        // The network subsystem deals with sending and receiving messages to and from peers.\n        const myPeerMetadata = (async () => ({\n            storageId: await storageSubsystem?.id(),\n            isEphemeral,\n        }))();\n        const networkSubsystem = new NetworkSubsystem(network, peerId, myPeerMetadata);\n        this.networkSubsystem = networkSubsystem;\n        // When we get a new peer, register it with the synchronizer\n        networkSubsystem.on(\"peer\", async ({ peerId, peerMetadata }) => {\n            this.#log(\"peer connected\", { peerId });\n            if (peerMetadata) {\n                this.peerMetadataByPeerId[peerId] = { ...peerMetadata };\n            }\n            this.sharePolicy(peerId)\n                .then(shouldShare => {\n                if (shouldShare && this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.addGenerousPeer(peerId);\n                }\n            })\n                .catch(err => {\n                console.log(\"error in share policy\", { err });\n            });\n            this.synchronizer.addPeer(peerId);\n        });\n        // When a peer disconnects, remove it from the synchronizer\n        networkSubsystem.on(\"peer-disconnected\", ({ peerId }) => {\n            this.synchronizer.removePeer(peerId);\n            this.#remoteHeadsSubscriptions.removePeer(peerId);\n        });\n        // Handle incoming messages\n        networkSubsystem.on(\"message\", async (msg) => {\n            this.#receiveMessage(msg);\n        });\n        this.synchronizer.on(\"sync-state\", message => {\n            this.#saveSyncState(message);\n            const handle = this.#handleCache[message.documentId];\n            const { storageId } = this.peerMetadataByPeerId[message.peerId] || {};\n            if (!storageId) {\n                return;\n            }\n            const heads = handle.getSyncInfo(storageId)?.lastHeads;\n            const haveHeadsChanged = message.syncState.theirHeads &&\n                (!heads ||\n                    !headsAreSame(heads, encodeHeads(message.syncState.theirHeads)));\n            if (haveHeadsChanged && message.syncState.theirHeads) {\n                handle.setSyncInfo(storageId, {\n                    lastHeads: encodeHeads(message.syncState.theirHeads),\n                    lastSyncTimestamp: Date.now(),\n                });\n                if (storageId && this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleImmediateRemoteHeadsChanged(message.documentId, storageId, encodeHeads(message.syncState.theirHeads));\n                }\n            }\n        });\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.#remoteHeadsSubscriptions.on(\"notify-remote-heads\", message => {\n                this.networkSubsystem.send({\n                    type: \"remote-heads-changed\",\n                    targetId: message.targetId,\n                    documentId: message.documentId,\n                    newHeads: {\n                        [message.storageId]: {\n                            heads: message.heads,\n                            timestamp: message.timestamp,\n                        },\n                    },\n                });\n            });\n            this.#remoteHeadsSubscriptions.on(\"change-remote-subs\", message => {\n                this.#log(\"change-remote-subs\", message);\n                for (const peer of message.peers) {\n                    this.networkSubsystem.send({\n                        type: \"remote-subscription-change\",\n                        targetId: peer,\n                        add: message.add,\n                        remove: message.remove,\n                    });\n                }\n            });\n            this.#remoteHeadsSubscriptions.on(\"remote-heads-changed\", ({ documentId, storageId, remoteHeads, timestamp }) => {\n                const handle = this.#handleCache[documentId];\n                handle.setSyncInfo(storageId, {\n                    lastHeads: remoteHeads,\n                    lastSyncTimestamp: timestamp,\n                });\n            });\n        }\n    }\n    // The `document` event is fired by the DocCollection any time we create a new document or look\n    // up a document by ID. We listen for it in order to wire up storage and network synchronization.\n    #registerHandleWithSubsystems(handle) {\n        if (this.storageSubsystem) {\n            // Add save function as a listener if it's not already registered\n            const existingListeners = handle.listeners(\"heads-changed\");\n            if (!existingListeners.some(listener => listener === this.#saveFn)) {\n                // Save when the document changes\n                handle.on(\"heads-changed\", this.#saveFn);\n            }\n        }\n        // Register the document with the synchronizer. This advertises our interest in the document.\n        this.synchronizer.addDocument(handle);\n    }\n    #receiveMessage(message) {\n        switch (message.type) {\n            case \"remote-subscription-change\":\n                if (this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleControlMessage(message);\n                }\n                break;\n            case \"remote-heads-changed\":\n                if (this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleRemoteHeads(message);\n                }\n                break;\n            case \"sync\":\n            case \"request\":\n            case \"ephemeral\":\n            case \"doc-unavailable\":\n                this.synchronizer.receiveMessage(message).catch(err => {\n                    console.log(\"error receiving message\", { err, message });\n                });\n        }\n    }\n    #throttledSaveSyncStateHandlers = {};\n    /** saves sync state throttled per storage id, if a peer doesn't have a storage id it's sync state is not persisted */\n    #saveSyncState(payload) {\n        if (!this.storageSubsystem) {\n            return;\n        }\n        const { storageId, isEphemeral } = this.peerMetadataByPeerId[payload.peerId] || {};\n        if (!storageId || isEphemeral) {\n            return;\n        }\n        let handler = this.#throttledSaveSyncStateHandlers[storageId];\n        if (!handler) {\n            handler = this.#throttledSaveSyncStateHandlers[storageId] = throttle(({ documentId, syncState }) => {\n                void this.storageSubsystem.saveSyncState(documentId, storageId, syncState);\n            }, this.#saveDebounceRate);\n        }\n        handler(payload);\n    }\n    /** Returns an existing handle if we have it; creates one otherwise. */\n    #getHandle({ documentId, }) {\n        // If we have the handle cached, return it\n        if (this.#handleCache[documentId])\n            return this.#handleCache[documentId];\n        // If not, create a new handle, cache it, and return it\n        if (!documentId)\n            throw new Error(`Invalid documentId ${documentId}`);\n        const handle = new DocHandle(documentId);\n        this.#handleCache[documentId] = handle;\n        return handle;\n    }\n    /** Returns all the handles we have cached. */\n    get handles() {\n        return this.#handleCache;\n    }\n    /** Returns a list of all connected peer ids */\n    get peers() {\n        return this.synchronizer.peers;\n    }\n    getStorageIdOfPeer(peerId) {\n        return this.peerMetadataByPeerId[peerId]?.storageId;\n    }\n    /**\n     * Creates a new document and returns a handle to it. The initial value of the document is an\n     * empty object `{}` unless an initial value is provided. Its documentId is generated by the\n     * system. we emit a `document` event to advertise interest in the document.\n     */\n    create(initialValue) {\n        // Generate a new UUID and store it in the buffer\n        const { documentId } = parseAutomergeUrl(generateAutomergeUrl());\n        const handle = this.#getHandle({\n            documentId,\n        });\n        this.#registerHandleWithSubsystems(handle);\n        handle.update(() => {\n            let nextDoc;\n            if (initialValue) {\n                nextDoc = Automerge.from(initialValue);\n            }\n            else {\n                nextDoc = Automerge.emptyChange(Automerge.init());\n            }\n            return nextDoc;\n        });\n        handle.doneLoading();\n        return handle;\n    }\n    /** Create a new DocHandle by cloning the history of an existing DocHandle.\n     *\n     * @param clonedHandle - The handle to clone\n     *\n     * @remarks This is a wrapper around the `clone` function in the Automerge library.\n     * The new `DocHandle` will have a new URL but will share history with the original,\n     * which means that changes made to the cloned handle can be sensibly merged back\n     * into the original.\n     *\n     * Any peers this `Repo` is connected to for whom `sharePolicy` returns `true` will\n     * be notified of the newly created DocHandle.\n     *\n     */\n    clone(clonedHandle) {\n        if (!clonedHandle.isReady()) {\n            throw new Error(`Cloned handle is not yet in ready state.\n        (Try await handle.whenReady() first.)`);\n        }\n        const sourceDoc = clonedHandle.doc();\n        const handle = this.create();\n        handle.update(() => {\n            // we replace the document with the new cloned one\n            return Automerge.clone(sourceDoc);\n        });\n        return handle;\n    }\n    findWithProgress(id, options = {}) {\n        const { signal } = options;\n        const { documentId, heads } = isValidAutomergeUrl(id)\n            ? parseAutomergeUrl(id)\n            : { documentId: interpretAsDocumentId(id), heads: undefined };\n        // Check handle cache first - return plain FindStep for terminal states\n        if (this.#handleCache[documentId]) {\n            const handle = this.#handleCache[documentId];\n            if (handle.state === UNAVAILABLE) {\n                const result = {\n                    state: \"unavailable\",\n                    error: new Error(`Document ${id} is unavailable`),\n                    handle,\n                };\n                return result;\n            }\n            if (handle.state === DELETED) {\n                const result = {\n                    state: \"failed\",\n                    error: new Error(`Document ${id} was deleted`),\n                    handle,\n                };\n                return result;\n            }\n            if (handle.state === READY) {\n                const result = {\n                    state: \"ready\",\n                    handle: heads ? handle.view(heads) : handle,\n                };\n                return result;\n            }\n        }\n        // Check progress cache for any existing signal\n        const cachedProgress = this.#progressCache[documentId];\n        if (cachedProgress) {\n            const handle = this.#handleCache[documentId];\n            // Return cached progress if we have a handle and it's either in a terminal state or loading\n            if (handle &&\n                (handle.state === READY ||\n                    handle.state === UNAVAILABLE ||\n                    handle.state === DELETED ||\n                    handle.state === \"loading\")) {\n                return cachedProgress;\n            }\n        }\n        const handle = this.#getHandle({ documentId });\n        const initial = {\n            state: \"loading\",\n            progress: 0,\n            handle,\n        };\n        // Create a new progress signal\n        const progressSignal = {\n            subscribers: new Set(),\n            currentProgress: undefined,\n            notify: (progress) => {\n                progressSignal.currentProgress = progress;\n                progressSignal.subscribers.forEach(callback => callback(progress));\n                // Cache all states, not just terminal ones\n                this.#progressCache[documentId] = progress;\n            },\n            peek: () => progressSignal.currentProgress || initial,\n            subscribe: (callback) => {\n                progressSignal.subscribers.add(callback);\n                return () => progressSignal.subscribers.delete(callback);\n            },\n        };\n        progressSignal.notify(initial);\n        // Start the loading process\n        void this.#loadDocumentWithProgress(id, documentId, handle, progressSignal, signal ? abortable(new Promise(() => { }), signal) : new Promise(() => { }));\n        const result = {\n            ...initial,\n            peek: progressSignal.peek,\n            subscribe: progressSignal.subscribe,\n        };\n        this.#progressCache[documentId] = result;\n        return result;\n    }\n    async #loadDocumentWithProgress(id, documentId, handle, progressSignal, abortPromise) {\n        try {\n            progressSignal.notify({\n                state: \"loading\",\n                progress: 25,\n                handle,\n            });\n            const loadingPromise = await (this.storageSubsystem\n                ? this.storageSubsystem.loadDoc(handle.documentId)\n                : Promise.resolve(null));\n            const loadedDoc = await Promise.race([loadingPromise, abortPromise]);\n            if (loadedDoc) {\n                handle.update(() => loadedDoc);\n                handle.doneLoading();\n                progressSignal.notify({\n                    state: \"loading\",\n                    progress: 50,\n                    handle,\n                });\n            }\n            else {\n                await Promise.race([this.networkSubsystem.whenReady(), abortPromise]);\n                handle.request();\n                progressSignal.notify({\n                    state: \"loading\",\n                    progress: 75,\n                    handle,\n                });\n            }\n            this.#registerHandleWithSubsystems(handle);\n            await Promise.race([handle.whenReady([READY, UNAVAILABLE]), abortPromise]);\n            if (handle.state === UNAVAILABLE) {\n                const unavailableProgress = {\n                    state: \"unavailable\",\n                    handle,\n                };\n                progressSignal.notify(unavailableProgress);\n                return;\n            }\n            if (handle.state === DELETED) {\n                throw new Error(`Document ${id} was deleted`);\n            }\n            progressSignal.notify({ state: \"ready\", handle });\n        }\n        catch (error) {\n            progressSignal.notify({\n                state: \"failed\",\n                error: error instanceof Error ? error : new Error(String(error)),\n                handle: this.#getHandle({ documentId }),\n            });\n        }\n    }\n    async find(id, options = {}) {\n        const { allowableStates = [\"ready\"], signal } = options;\n        // Check if already aborted\n        if (signal?.aborted) {\n            throw new Error(\"Operation aborted\");\n        }\n        const progress = this.findWithProgress(id, { signal });\n        if (\"subscribe\" in progress) {\n            this.#registerHandleWithSubsystems(progress.handle);\n            return new Promise((resolve, reject) => {\n                const unsubscribe = progress.subscribe(state => {\n                    if (allowableStates.includes(state.handle.state)) {\n                        unsubscribe();\n                        resolve(state.handle);\n                    }\n                    else if (state.state === \"unavailable\") {\n                        unsubscribe();\n                        reject(new Error(`Document ${id} is unavailable`));\n                    }\n                    else if (state.state === \"failed\") {\n                        unsubscribe();\n                        reject(state.error);\n                    }\n                });\n            });\n        }\n        else {\n            if (progress.handle.state === READY) {\n                return progress.handle;\n            }\n            // If the handle isn't ready, wait for it and then return it\n            await progress.handle.whenReady([READY, UNAVAILABLE]);\n            if (progress.handle.state === \"unavailable\" &&\n                !allowableStates.includes(UNAVAILABLE)) {\n                throw new Error(`Document ${id} is unavailable`);\n            }\n            return progress.handle;\n        }\n    }\n    /**\n     * Loads a document without waiting for ready state\n     */\n    async #loadDocument(documentId) {\n        // If we have the handle cached, return it\n        if (this.#handleCache[documentId]) {\n            return this.#handleCache[documentId];\n        }\n        // If we don't already have the handle, make an empty one and try loading it\n        const handle = this.#getHandle({ documentId });\n        const loadedDoc = await (this.storageSubsystem\n            ? this.storageSubsystem.loadDoc(handle.documentId)\n            : Promise.resolve(null));\n        if (loadedDoc) {\n            // We need to cast this to <T> because loadDoc operates in <unknowns>.\n            // This is really where we ought to be validating the input matches <T>.\n            handle.update(() => loadedDoc);\n            handle.doneLoading();\n        }\n        else {\n            // Because the network subsystem might still be booting up, we wait\n            // here so that we don't immediately give up loading because we're still\n            // making our initial connection to a sync server.\n            await this.networkSubsystem.whenReady();\n            handle.request();\n        }\n        this.#registerHandleWithSubsystems(handle);\n        return handle;\n    }\n    /**\n     * Retrieves a document by id. It gets data from the local system, but also emits a `document`\n     * event to advertise interest in the document.\n     */\n    async findClassic(\n    /** The url or documentId of the handle to retrieve */\n    id, options = {}) {\n        const documentId = interpretAsDocumentId(id);\n        const { allowableStates, signal } = options;\n        return abortable((async () => {\n            const handle = await this.#loadDocument(documentId);\n            if (!allowableStates) {\n                await handle.whenReady([READY, UNAVAILABLE]);\n                if (handle.state === UNAVAILABLE && !signal?.aborted) {\n                    throw new Error(`Document ${id} is unavailable`);\n                }\n            }\n            return handle;\n        })(), signal);\n    }\n    delete(\n    /** The url or documentId of the handle to delete */\n    id) {\n        const documentId = interpretAsDocumentId(id);\n        const handle = this.#getHandle({ documentId });\n        handle.delete();\n        delete this.#handleCache[documentId];\n        delete this.#progressCache[documentId];\n        this.emit(\"delete-document\", { documentId });\n    }\n    /**\n     * Exports a document to a binary format.\n     * @param id - The url or documentId of the handle to export\n     *\n     * @returns Promise<Uint8Array | undefined> - A Promise containing the binary document,\n     * or undefined if the document is unavailable.\n     */\n    async export(id) {\n        const documentId = interpretAsDocumentId(id);\n        const handle = this.#getHandle({ documentId });\n        const doc = handle.doc();\n        return Automerge.save(doc);\n    }\n    /**\n     * Imports document binary into the repo.\n     * @param binary - The binary to import\n     */\n    import(binary) {\n        const doc = Automerge.load(binary);\n        const handle = this.create();\n        handle.update(() => {\n            return Automerge.clone(doc);\n        });\n        return handle;\n    }\n    subscribeToRemotes = (remotes) => {\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.#log(\"subscribeToRemotes\", { remotes });\n            this.#remoteHeadsSubscriptions.subscribeToRemotes(remotes);\n        }\n        else {\n            this.#log(\"WARN: subscribeToRemotes called but remote heads gossiping is not enabled\");\n        }\n    };\n    storageId = async () => {\n        if (!this.storageSubsystem) {\n            return undefined;\n        }\n        else {\n            return this.storageSubsystem.id();\n        }\n    };\n    /**\n     * Writes Documents to a disk.\n     * @hidden this API is experimental and may change.\n     * @param documents - if provided, only writes the specified documents.\n     * @returns Promise<void>\n     */\n    async flush(documents) {\n        if (!this.storageSubsystem) {\n            return;\n        }\n        const handles = documents\n            ? documents.map(id => this.#handleCache[id])\n            : Object.values(this.#handleCache);\n        await Promise.all(handles.map(async (handle) => {\n            return this.storageSubsystem.saveDoc(handle.documentId, handle.doc());\n        }));\n    }\n    /**\n     * Removes a DocHandle from the handleCache.\n     * @hidden this API is experimental and may change.\n     * @param documentId - documentId of the DocHandle to remove from handleCache, if present in cache.\n     * @returns Promise<void>\n     */\n    async removeFromCache(documentId) {\n        if (!this.#handleCache[documentId]) {\n            this.#log(`WARN: removeFromCache called but handle not found in handleCache for documentId: ${documentId}`);\n            return;\n        }\n        const handle = this.#getHandle({ documentId });\n        await handle.whenReady([READY, UNLOADED, DELETED, UNAVAILABLE]);\n        const doc = handle.doc();\n        // because this is an internal-ish function, we'll be extra careful about undefined docs here\n        if (doc) {\n            if (handle.isReady()) {\n                handle.unload();\n            }\n            else {\n                this.#log(`WARN: removeFromCache called but handle for documentId: ${documentId} in unexpected state: ${handle.state}`);\n            }\n            delete this.#handleCache[documentId];\n            delete this.#progressCache[documentId];\n            this.synchronizer.removeDocument(documentId);\n        }\n        else {\n            this.#log(`WARN: removeFromCache called but doc undefined for documentId: ${documentId}`);\n        }\n    }\n    shutdown() {\n        this.networkSubsystem.adapters.forEach(adapter => {\n            adapter.disconnect();\n        });\n        return this.flush();\n    }\n    metrics() {\n        return { documents: this.synchronizer.metrics() };\n    }\n}\n","/* c8 ignore start */\nimport { EventEmitter } from \"eventemitter3\";\n/** An interface representing some way to connect to other peers\n *\n * @remarks\n * The {@link Repo} uses one or more `NetworkAdapter`s to connect to other peers.\n * Because the network may take some time to be ready the {@link Repo} will wait\n * until the adapter emits a `ready` event before it starts trying to use it\n *\n * This utility class can be used as a base to build a custom network adapter. It\n * is most useful as a simple way to add the necessary event emitter functionality\n */\nexport class NetworkAdapter extends EventEmitter {\n    peerId;\n    peerMetadata;\n}\n","/**\n * This module provides a storage adapter for IndexedDB.\n *\n * @packageDocumentation\n */\nexport class IndexedDBStorageAdapter {\n    database;\n    store;\n    dbPromise;\n    /** Create a new {@link IndexedDBStorageAdapter}.\n     * @param database - The name of the database to use. Defaults to \"automerge\".\n     * @param store - The name of the object store to use. Defaults to \"documents\".\n     */\n    constructor(database = \"automerge\", store = \"documents\") {\n        this.database = database;\n        this.store = store;\n        this.dbPromise = this.createDatabasePromise();\n    }\n    createDatabasePromise() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.database, 1);\n            request.onerror = () => {\n                reject(request.error);\n            };\n            request.onupgradeneeded = event => {\n                const db = event.target.result;\n                db.createObjectStore(this.store);\n            };\n            request.onsuccess = event => {\n                const db = event.target.result;\n                resolve(db);\n            };\n        });\n    }\n    async load(keyArray) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store);\n        const objectStore = transaction.objectStore(this.store);\n        const request = objectStore.get(keyArray);\n        return new Promise((resolve, reject) => {\n            transaction.onerror = () => {\n                reject(request.error);\n            };\n            request.onsuccess = event => {\n                const result = event.target.result;\n                if (result && typeof result === \"object\" && \"binary\" in result) {\n                    resolve(result.binary);\n                }\n                else {\n                    resolve(undefined);\n                }\n            };\n        });\n    }\n    async save(keyArray, binary) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.put({ key: keyArray, binary: binary }, keyArray);\n        return new Promise((resolve, reject) => {\n            transaction.onerror = () => {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () => {\n                resolve();\n            };\n        });\n    }\n    async remove(keyArray) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.delete(keyArray);\n        return new Promise((resolve, reject) => {\n            transaction.onerror = () => {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () => {\n                resolve();\n            };\n        });\n    }\n    async loadRange(keyPrefix) {\n        const db = await this.dbPromise;\n        const lowerBound = keyPrefix;\n        const upperBound = [...keyPrefix, \"\\uffff\"];\n        const range = IDBKeyRange.bound(lowerBound, upperBound);\n        const transaction = db.transaction(this.store);\n        const objectStore = transaction.objectStore(this.store);\n        const request = objectStore.openCursor(range);\n        const result = [];\n        return new Promise((resolve, reject) => {\n            transaction.onerror = () => {\n                reject(request.error);\n            };\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    result.push({\n                        data: cursor.value.binary,\n                        key: cursor.key,\n                    });\n                    cursor.continue();\n                }\n                else {\n                    resolve(result);\n                }\n            };\n        });\n    }\n    async removeRange(keyPrefix) {\n        const db = await this.dbPromise;\n        const lowerBound = keyPrefix;\n        const upperBound = [...keyPrefix, \"\\uffff\"];\n        const range = IDBKeyRange.bound(lowerBound, upperBound);\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.delete(range);\n        return new Promise((resolve, reject) => {\n            transaction.onerror = () => {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () => {\n                resolve();\n            };\n        });\n    }\n}\n","// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nexport default ws\n","// TYPE GUARDS\nexport const isJoinMessage = (message) => message.type === \"join\";\nexport const isPeerMessage = (message) => message.type === \"peer\";\nexport const isErrorMessage = (message) => message.type === \"error\";\n","export const ProtocolV1 = \"1\";\n","/* c8 ignore start */\nexport function assert(value, message = \"Assertion failed\") {\n    if (value === false || value === null || value === undefined) {\n        const error = new Error(trimLines(message));\n        error.stack = removeLine(error.stack, \"assert.ts\");\n        throw error;\n    }\n}\nconst trimLines = (s) => s\n    .split(\"\\n\")\n    .map(s => s.trim())\n    .join(\"\\n\");\nconst removeLine = (s = \"\", targetText) => s\n    .split(\"\\n\")\n    .filter(line => !line.includes(targetText))\n    .join(\"\\n\");\n/* c8 ignore end */\n","/**\n * This incantation deals with websocket sending the whole underlying buffer even if we just have a\n * uint8array view on it\n */\nexport const toArrayBuffer = (bytes) => {\n    const { buffer, byteOffset, byteLength } = bytes;\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n};\n","import { NetworkAdapter, cbor, } from \"@automerge/automerge-repo/slim\";\nimport WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nimport { isErrorMessage, isPeerMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nclass WebSocketNetworkAdapter extends NetworkAdapter {\n    socket;\n}\nexport class WebSocketClientAdapter extends WebSocketNetworkAdapter {\n    url;\n    retryInterval;\n    #ready = false;\n    #readyResolver;\n    #readyPromise = new Promise(resolve => {\n        this.#readyResolver = resolve;\n    });\n    isReady() {\n        return this.#ready;\n    }\n    whenReady() {\n        return this.#readyPromise;\n    }\n    #forceReady() {\n        if (!this.#ready) {\n            this.#ready = true;\n            this.#readyResolver?.();\n        }\n    }\n    #retryIntervalId;\n    #log = debug(\"automerge-repo:websocket:browser\");\n    remotePeerId; // this adapter only connects to one remote client at a time\n    constructor(url, retryInterval = 5000) {\n        super();\n        this.url = url;\n        this.retryInterval = retryInterval;\n        this.#log = this.#log.extend(url);\n    }\n    connect(peerId, peerMetadata) {\n        if (!this.socket || !this.peerId) {\n            // first time connecting\n            this.#log(\"connecting\");\n            this.peerId = peerId;\n            this.peerMetadata = peerMetadata ?? {};\n        }\n        else {\n            this.#log(\"reconnecting\");\n            assert(peerId === this.peerId);\n            // Remove the old event listeners before creating a new connection.\n            this.socket.removeEventListener(\"open\", this.onOpen);\n            this.socket.removeEventListener(\"close\", this.onClose);\n            this.socket.removeEventListener(\"message\", this.onMessage);\n            this.socket.removeEventListener(\"error\", this.onError);\n        }\n        // Wire up retries\n        if (!this.#retryIntervalId)\n            this.#retryIntervalId = setInterval(() => {\n                this.connect(peerId, peerMetadata);\n            }, this.retryInterval);\n        this.socket = new WebSocket(this.url);\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.addEventListener(\"open\", this.onOpen);\n        this.socket.addEventListener(\"close\", this.onClose);\n        this.socket.addEventListener(\"message\", this.onMessage);\n        this.socket.addEventListener(\"error\", this.onError);\n        // Mark this adapter as ready if we haven't received an ack in 1 second.\n        // We might hear back from the other end at some point but we shouldn't\n        // hold up marking things as unavailable for any longer\n        setTimeout(() => this.#forceReady(), 1000);\n        this.join();\n    }\n    onOpen = () => {\n        this.#log(\"open\");\n        clearInterval(this.#retryIntervalId);\n        this.#retryIntervalId = undefined;\n        this.join();\n    };\n    // When a socket closes, or disconnects, remove it from the array.\n    onClose = () => {\n        this.#log(\"close\");\n        if (this.remotePeerId)\n            this.emit(\"peer-disconnected\", { peerId: this.remotePeerId });\n        if (this.retryInterval > 0 && !this.#retryIntervalId)\n            // try to reconnect\n            setTimeout(() => {\n                assert(this.peerId);\n                return this.connect(this.peerId, this.peerMetadata);\n            }, this.retryInterval);\n    };\n    onMessage = (event) => {\n        this.receiveMessage(event.data);\n    };\n    /** The websocket error handler signature is different on node and the browser.  */\n    onError = (event // node\n    ) => {\n        if (\"error\" in event) {\n            // (node)\n            if (event.error.code !== \"ECONNREFUSED\") {\n                /* c8 ignore next */\n                throw event.error;\n            }\n        }\n        else {\n            // (browser) We get no information about errors. https://stackoverflow.com/a/31003057/239663\n            // There will be an error logged in the console (`WebSocket connection to 'wss://foo.com/'\n            // failed`), but by design the error is unavailable to scripts. We'll just assume this is a\n            // failed connection.\n        }\n        this.#log(\"Connection failed, retrying...\");\n    };\n    join() {\n        assert(this.peerId);\n        assert(this.socket);\n        if (this.socket.readyState === WebSocket.OPEN) {\n            this.send(joinMessage(this.peerId, this.peerMetadata));\n        }\n        else {\n            // We'll try again in the `onOpen` handler\n        }\n    }\n    disconnect() {\n        assert(this.peerId);\n        assert(this.socket);\n        const socket = this.socket;\n        if (socket) {\n            socket.removeEventListener(\"open\", this.onOpen);\n            socket.removeEventListener(\"close\", this.onClose);\n            socket.removeEventListener(\"message\", this.onMessage);\n            socket.removeEventListener(\"error\", this.onError);\n            socket.close();\n        }\n        clearInterval(this.#retryIntervalId);\n        if (this.remotePeerId)\n            this.emit(\"peer-disconnected\", { peerId: this.remotePeerId });\n        this.socket = undefined;\n    }\n    send(message) {\n        if (\"data\" in message && message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        assert(this.peerId);\n        if (!this.socket) {\n            this.#log(\"Tried to send on a disconnected socket.\");\n            return;\n        }\n        if (this.socket.readyState !== WebSocket.OPEN)\n            throw new Error(`Websocket not ready (${this.socket.readyState})`);\n        const encoded = cbor.encode(message);\n        this.socket.send(toArrayBuffer(encoded));\n    }\n    peerCandidate(remotePeerId, peerMetadata) {\n        assert(this.socket);\n        this.#forceReady();\n        this.remotePeerId = remotePeerId;\n        this.emit(\"peer-candidate\", {\n            peerId: remotePeerId,\n            peerMetadata,\n        });\n    }\n    receiveMessage(messageBytes) {\n        let message;\n        try {\n            message = cbor.decode(new Uint8Array(messageBytes));\n        }\n        catch (e) {\n            this.#log(\"error decoding message:\", e);\n            return;\n        }\n        assert(this.socket);\n        if (messageBytes.byteLength === 0)\n            throw new Error(\"received a zero-length message\");\n        if (isPeerMessage(message)) {\n            const { peerMetadata } = message;\n            this.#log(`peer: ${message.senderId}`);\n            this.peerCandidate(message.senderId, peerMetadata);\n        }\n        else if (isErrorMessage(message)) {\n            this.#log(`error: ${message.message}`);\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n}\nfunction joinMessage(senderId, peerMetadata) {\n    return {\n        type: \"join\",\n        senderId,\n        peerMetadata,\n        supportedProtocolVersions: [ProtocolV1],\n    };\n}\n","import WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nconst log = debug(\"WebsocketServer\");\nimport { cbor as cborHelpers, NetworkAdapter, } from \"@automerge/automerge-repo/slim\";\nimport { isJoinMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nconst { encode, decode } = cborHelpers;\nexport class WebSocketServerAdapter extends NetworkAdapter {\n    server;\n    keepAliveInterval;\n    sockets = {};\n    #ready = false;\n    #readyResolver;\n    #readyPromise = new Promise(resolve => {\n        this.#readyResolver = resolve;\n    });\n    isReady() {\n        return this.#ready;\n    }\n    whenReady() {\n        return this.#readyPromise;\n    }\n    #forceReady() {\n        if (!this.#ready) {\n            this.#ready = true;\n            this.#readyResolver?.();\n        }\n    }\n    constructor(server, keepAliveInterval = 5000) {\n        super();\n        this.server = server;\n        this.keepAliveInterval = keepAliveInterval;\n    }\n    connect(peerId, peerMetadata) {\n        this.peerId = peerId;\n        this.peerMetadata = peerMetadata;\n        this.server.on(\"close\", () => {\n            clearInterval(keepAliveId);\n            this.disconnect();\n        });\n        this.server.on(\"connection\", (socket) => {\n            // When a socket closes, or disconnects, remove it from our list\n            socket.on(\"close\", () => {\n                this.#removeSocket(socket);\n            });\n            socket.on(\"message\", message => this.receiveMessage(message, socket));\n            // Start out \"alive\", and every time we get a pong, reset that state.\n            socket.isAlive = true;\n            socket.on(\"pong\", () => (socket.isAlive = true));\n            this.#forceReady();\n        });\n        const keepAliveId = setInterval(() => {\n            // Terminate connections to lost clients\n            const clients = this.server.clients;\n            clients.forEach(socket => {\n                if (socket.isAlive) {\n                    // Mark all clients as potentially dead until we hear from them\n                    socket.isAlive = false;\n                    socket.ping();\n                }\n                else {\n                    this.#terminate(socket);\n                }\n            });\n        }, this.keepAliveInterval);\n    }\n    disconnect() {\n        const clients = this.server.clients;\n        clients.forEach(socket => {\n            this.#terminate(socket);\n            this.#removeSocket(socket);\n        });\n    }\n    send(message) {\n        assert(\"targetId\" in message && message.targetId !== undefined);\n        if (\"data\" in message && message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        const senderId = this.peerId;\n        assert(senderId, \"No peerId set for the websocket server network adapter.\");\n        const socket = this.sockets[message.targetId];\n        if (!socket) {\n            log(`Tried to send to disconnected peer: ${message.targetId}`);\n            return;\n        }\n        const encoded = encode(message);\n        const arrayBuf = toArrayBuffer(encoded);\n        socket.send(arrayBuf);\n    }\n    receiveMessage(messageBytes, socket) {\n        let message;\n        try {\n            message = decode(messageBytes);\n        }\n        catch (e) {\n            log(\"invalid message received, closing connection\");\n            socket.close();\n            return;\n        }\n        const { type, senderId } = message;\n        const myPeerId = this.peerId;\n        assert(myPeerId);\n        const documentId = \"documentId\" in message ? \"@\" + message.documentId : \"\";\n        const { byteLength } = messageBytes;\n        log(`[${senderId}->${myPeerId}${documentId}] ${type} | ${byteLength} bytes`);\n        if (isJoinMessage(message)) {\n            const { peerMetadata, supportedProtocolVersions } = message;\n            const existingSocket = this.sockets[senderId];\n            if (existingSocket) {\n                if (existingSocket.readyState === WebSocket.OPEN) {\n                    existingSocket.close();\n                }\n                this.emit(\"peer-disconnected\", { peerId: senderId });\n            }\n            // Let the repo know that we have a new connection.\n            this.emit(\"peer-candidate\", { peerId: senderId, peerMetadata });\n            this.sockets[senderId] = socket;\n            const selectedProtocolVersion = selectProtocol(supportedProtocolVersions);\n            if (selectedProtocolVersion === null) {\n                this.send({\n                    type: \"error\",\n                    senderId: this.peerId,\n                    message: \"unsupported protocol version\",\n                    targetId: senderId,\n                });\n                this.sockets[senderId].close();\n                delete this.sockets[senderId];\n            }\n            else {\n                this.send({\n                    type: \"peer\",\n                    senderId: this.peerId,\n                    peerMetadata: this.peerMetadata,\n                    selectedProtocolVersion: ProtocolV1,\n                    targetId: senderId,\n                });\n            }\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n    #terminate(socket) {\n        this.#removeSocket(socket);\n        socket.terminate();\n    }\n    #removeSocket(socket) {\n        const peerId = this.#peerIdBySocket(socket);\n        if (!peerId)\n            return;\n        this.emit(\"peer-disconnected\", { peerId });\n        delete this.sockets[peerId];\n    }\n    #peerIdBySocket = (socket) => {\n        const isThisSocket = (peerId) => this.sockets[peerId] === socket;\n        const result = Object.keys(this.sockets).find(isThisSocket);\n        return result ?? null;\n    };\n}\nconst selectProtocol = (versions) => {\n    if (versions === undefined)\n        return ProtocolV1;\n    if (versions.includes(ProtocolV1))\n        return ProtocolV1;\n    return null;\n};\n","// Note the ?url suffix\nimport wasmUrl from \"@automerge/automerge/automerge.wasm?url\";\n// Note the `/slim` suffixes\nimport * as Automerge from \"@automerge/automerge/slim\";\nimport { Repo } from \"@automerge/automerge-repo/slim\";\nimport { IndexedDBStorageAdapter } from \"@automerge/automerge-repo-storage-indexeddb\";\nimport { BrowserWebSocketClientAdapter } from \"@automerge/automerge-repo-network-websocket\";\n\nawait Automerge.initializeWasm(wasmUrl);\n\nconst statusDiv = document.getElementById(\"status\");\nconst documentPre = document.getElementById(\"document\");\nconst updateButton = document.getElementById(\"updateButton\");\n\n// 1. Create a repo.\nconst repo = new Repo({\n  storage: new IndexedDBStorageAdapter(),\n  // Connect to the Go server's WebSocket endpoint.\n  network: [new BrowserWebSocketClientAdapter(\"ws://localhost:1323/ws\")],\n  // Share policy is required to sync documents.\n  sharePolicy: async (peerId, docId) => true,\n});\n\n// 2. Get a handle to a document.\n// If the document doesn't exist, it will be created.\nconst docUrl = \"automerge:9k54321Abcde\";\nconst handle = repo.find(docUrl);\n\nstatusDiv.textContent = \"Repo initialized. Waiting for document...\";\n\n// 3. Register a listener for document changes.\nhandle.on(\"change\", ({ doc }) => {\n  console.log(\"Document changed:\", doc);\n  // Update the UI with the new document state.\n  documentPre.textContent = JSON.stringify(doc, null, 2);\n  statusDiv.textContent = `Connected. Last change: ${new Date().toLocaleTimeString()}`;\n});\n\n// 4. Set up the button to modify the document.\nupdateButton.addEventListener(\"click\", () => {\n  if (!handle.isReady()) {\n    alert(\"Document not ready yet. Please wait.\");\n    return;\n  }\n  // Use handle.change() to make a modification.\n  handle.change((doc) => {\n    doc.timestamp = new Date().toISOString();\n    doc.counter = (doc.counter || 0) + 1;\n    console.log(\"Making a change...\");\n  });\n});\n\n// Log the repo object for debugging.\nconsole.log(\"Automerge Repo setup complete.\", repo);\n"],"names":["wasmUrl","STATE","TRACE","OBJECT_ID","IS_PROXY","CLEAR_CACHE","UINT","INT","F64","COUNTER","IMMUTABLE_STRING","Counter","value","_delta","WriteableCounter","context","path","objectId","key","delta","getWriteableCounter","_a","ImmutableString","val","parseListIndex","valueAt","target","prop","datatype","mapProxy","listProxy","import_value","type","isImmutableString","isSameDocument","printPath","_b","_c","MapHandler","cache","list","proxyList","i","map","proxyMap","keys","ListHandler","index","instance","listMethods","elem","textMethods","proxied","rootProxy","numDelete","start","end","length","searchElement","valueWithType","valType","values","last","len","first","del","vals","result","e","f","other","v","sep","initialValue","search","fromIndex","num","spans","chars","o","jsonPointerComponents","component","obj","wasm","WASM_VECTOR_LEN","cachedUint8ArrayMemory0","getUint8ArrayMemory0","cachedTextEncoder","encodeString","arg","view","buf","passStringToWasm0","malloc","realloc","ptr","mem","offset","code","ret","cachedDataViewMemory0","getDataViewMemory0","addToExternrefTable0","idx","handleError","args","cachedTextDecoder","getStringFromWasm0","isLikeNone","x","debugString","description","name","debug","builtInMatches","className","takeFromExternrefTable0","_assertClass","klass","create","options","Automerge","load","data","encodeChange","change","decodeChange","initSyncState","SyncState","importSyncState","state","exportSyncState","encodeSyncMessage","message","decodeSyncMessage","msg","encodeSyncState","decodeSyncState","AutomergeFinalization","actor","ptr0","len0","heads","time","deferred2_0","deferred2_1","ptr1","len1","delete_count","text","new_text","block","enable","construct","deconstruct","object","meta","before","after","changes","have_deps","hash","deferred1_0","deferred1_1","position","move_cursor","cursor","range","SyncStateFinalization","hashes","__wbg_load","module","imports","bytes","__wbg_get_imports","arg0","arg1","arg2","deferred0_0","deferred0_1","table","__wbg_finalize_init","__wbg_init","initSync","module_or_path","_initializeListeners","UseApi","api","k","ApiHandler","listener","initializeWasm","wasmBlob","initWasm","_","WasmApi","_state","doc","checkroot","_obj","_trace","_is_proxy","__rest","s","t","p","importOpts","_actor","init","_opts","opts","freeze","patchCallback","handle","registerDatatypes","clone","_oldHeads","stateSansHeads","from","initialState","_change","d","callback","changeAt","scope","progressDocument","source","nextState","nextDoc","patches","newState","headsEqual","root","newHead","emptyChange","loadIncremental","unchecked","allowMissingDeps","convertImmutableStringsToText","save","merge","local","remote","localState","remoteState","diff","checkHeads","equals","heads1","heads2","fieldname","val1","val2","isObject","keys1","keys2","sync","generateSyncMessage","inState","syncState","receiveSyncMessage","outSyncState","getHeads","saveSince","n","topoHistoryTraversal","inspectChange","changeHash","stats","m","h","w","y","ms","parse","fmtLong","fmtShort","str","match","msAbs","plural","isPlural","setup","env","createDebug","coerce","disable","enabled","require$$0","destroy","selectColor","namespace","prevTime","enableOverride","namespacesCache","enabledCache","self","curr","format","formatter","extend","delimiter","newDebug","namespaces","split","ns","matchesTemplate","template","searchIndex","templateIndex","starIndex","matchIndex","skip","common","exports","formatArgs","useColors","localstorage","warned","c","lastC","r","define_process_env_default","formatters","error","has","prefix","Events","EE","fn","once","addListener","emitter","event","evt","clearEvent","EventEmitter","names","events","handlers","ee","listeners","a1","a2","a3","a4","a5","j","getGlobal","getDevTools","devToolsAdapter","service","devTools","Mailbox","_process","enqueued","consumed","STATE_DELIMITER","TARGETLESS_KEY","NULL_EVENT","STATE_IDENTIFIER","WILDCARD","XSTATE_INIT","XSTATE_STOP","createAfterEvent","delayRef","id","createDoneStateEvent","output","createDoneActorEvent","invokeId","createErrorActorEvent","createInitEvent","input","reportUnhandledError","err","symbolObservable","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","toStatePath","stateId","isArray","segment","stateValue","isMachineSnapshot","statePath","pathToStateValue","marker","previous","mapValues","collection","iteratee","collectionKeys","toArrayStrict","toArray","resolveOutput","mapper","isErrorActorEvent","toTransitionConfigArray","configLike","transitionLike","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","createInvokeId","stateNodeId","resolveReferencedActor","machine","src","indexStr","nodeId","invokeConfig","createScheduledEventId","actorRef","idCounter","createSystem","rootActor","children","keyedActors","reverseKeyedActors","inspectionObservers","timerMap","clock","logger","scheduler","delay","scheduledEvent","scheduledEventId","system","timeout","sendInspectionEvent","resolvedInspectionEvent","observer","sessionId","systemId","existing","observerOrFn","scheduledEvents","scheduledId","executingCustomAction","$$ACTOR_TYPE","ProcessingStatus","defaultOptions","Actor","logic","resolvedOptions","parent","syncSnapshot","inspect","child","emittedEvent","wildcardListener","allListeners","handler","action","exec","saveExecutingCustomAction","persistedState","snapshot","deferredFn","nextListenerOrObserver","errorListener","completeListener","wrappedHandler","initEvent","caughtError","reportError","err2","createActor","resolveCancel","actionArgs","actionParams","sendId","resolvedSendId","executeCancel","actorScope","params","cancel","_args","_params","resolveSpawn","_actionParams","resolvedId","resolvedInput","cloneMachineSnapshot","executeSpawn","spawnChild","resolveStop","actorRefOrString","resolvedActorRef","executeStop","stopChild","stop","evaluateGuard","guard","isInline","resolved","guardArgs","guardParams","isAtomicStateNode","stateNode","getChildren","sn","getProperAncestors","toStateNode","ancestors","getAllStateNodes","stateNodes","nodeSet","adjList","getAdjList","getInitialStateNodesWithTheirAncestors","initialStates","initialStateNode","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","config","isInFinalState","stateNodeSet","isStateId","getCandidates","receivedEventType","eventDescriptor","partialEventTokens","eventTokens","tokenIndex","partialEventToken","eventToken","a","b","getDelayedTransitions","afterConfig","mutateEntryExit","afterEvent","eventType","raise","configTransition","resolvedTransition","resolvedDelay","transition","delayedTransition","formatTransition","descriptor","transitionConfig","normalizedTarget","reenter","resolveTarget","formatTransitions","transitions","transitionsConfig","invokeDef","formatInitialTransition","_target","resolvedTarget","targets","isInternalTarget","getStateNodeByPath","resolveHistoryDefaultTransition","isHistoryNode","states","getInitialStateNodes","ancestor","set","iter","descStateNode","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","childStateKeys","subStateKey","allSubStateNodes","subStateNode","subStateNodes","transitionAtomicNode","next","transitionCompoundNode","subStateKeys","transitionNode","transitionParallelNode","allInnerTransitions","subStateValue","innerTransitions","getHistoryNodes","isDescendant","parentStateNode","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","findLeastCommonAncestor","head","tail","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","lca","statesToExit","domain","areStateNodeCollectionsEqual","prevStateNodes","nextStateNodeSet","microstep","currentSnapshot","isInitial","internalQueue","mutStateNodeSet","exitStates","resolveActionsAndContext","enterStates","nextStateNodes","getMachineOutput","rootCompletionNode","doneStateEvent","nextSnapshot","statesToEnter","statesForDefaultEntry","computeEntrySet","completedNodes","stateNodeToEnter","actions","initialActions","ancestorMarker","addDescendantStatesToEnter","addAncestorStatesToEnter","historyStateNodes","addProperAncestorStatesToEnter","historyDefaultTransition","reentrancyDomain","anc","_actionExecutor","changedHistory","exitStateNode","historyNode","predicate","def","getAction","actionType","resolveAndExecuteActionsWithContext","extra","retries","intermediateSnapshot","resolvedAction","builtinAction","deferredActorIds","macrostep","microstates","addMicrostate","microstate","stopChildren","nextEvent","currentEvent","isErr","selectTransitions","shouldSelectEventlessTransitions","selectEventlessTransitions","previousState","enabledTransitionSet","atomicStates","loop","resolveStateValue","allStateNodes","machineSnapshotMatches","testValue","machineSnapshotHasTag","tag","machineSnapshotCan","transitionData","machineSnapshotToJSON","nodes","tags","getMeta","toJSON","can","hasTag","matches","jsonValues","machineSnapshotGetMeta","acc","createMachineSnapshot","serializeHistoryValue","getPersistedSnapshot","childrenJson","persistContext","contextPart","copy","resolveRaise","eventOrExpr","delaysMap","resolvedEvent","configDelay","executeRaise","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","updatedContext","assign","memo","memoizedData","EMPTY_OBJECT","toSerializableAction","StateNode","stateConfig","sourceName","onDone","onError","invokeDefValues","selectedTransition","candidates","candidate","resolvedContext","guardPassed","guardType","StateMachine","implementations","guards","actors","delays","resolvedStateValue","preInitial","preInitialState","macroState","fullPath","relativePath","resolvedStateId","_actorScope","snapshotChildren","actorId","actorData","childState","resolveHistoryReferencedState","referenced","reviveHistoryValue","revived","arr","revivedHistoryValue","restoredSnapshot","seen","reviveContext","assertEvent","types","typesText","createMachine","schemas","defaultWaitForOptions","waitFor","res","rej","signal","done","dispose","sub","abortListener","checkEmitted","emitted","getRandomValues","rnds8","rng","REGEX","validate","uuid","byteToHex","unsafeStringify","stringify","randomUUID","native","v4","rnds","crypto","isBytes","anumber","abytes","ahash","aexists","aoutput","u8","u32","clean","createView","rotr","rotl","byteSwap","byteSwap32","bytesToHex","hexToBytes","asyncLoop","utf8ToBytes","bytesToUtf8","toBytes","kdfInputToBytes","concatBytes","checkOpts","createHasher","createOptHasher","createXOFer","randomBytes","crypto_1","lengths","checkFinished","out","min","arrays","word","shift","u","hasHexBuiltin","hexes","hex","asciis","asciiToBase16","ch","hl","al","array","ai","hi","n1","n2","char","nextTick","iters","tick","cb","ts","sum","pad","defaults","Hash","hashCons","hashC","tmp","bytesLength","_md","setBigUint64","Chi","Maj","utils_ts_1","byteOffset","isLE","_32n","_u32_max","wh","wl","l","HashMD","blockLen","outputLen","padOffset","buffer","pos","take","dataView","oview","outLen","to","finished","destroyed","_u64","add","fromBig","U32_MASK64","le","lst","Ah","Al","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","u64","sha2","_md_ts_1","require$$1","require$$2","SHA256_K","SHA256_W","SHA256","A","B","C","D","E","F","G","H","W15","W2","s0","sigma1","T1","T2","SHA224","K512","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","SHA384","T224_IV","T256_IV","SHA512_224","SHA512_256","sha256","sha2_ts_1","base","ALPHABET","BASE_MAP","xc","BASE","LEADER","FACTOR","iFACTOR","encode","zeroes","pbegin","pend","size","b58","carry","it1","it2","decodeUnsafe","psz","b256","charCode","it3","it4","vch","decode","string","bs58","base58","checksumFn","payload","payloadU8","checksum","both","decodeRaw","newChecksum","bs58checkBase","sha256x2","bs58check","uint8ArrayFromHexString","hexString","uint8ArrayToHexString","byte","urlPrefix","parseAutomergeUrl","url","baseUrl","headsSection","rest","regex","docMatch","documentId","binaryDocumentId","documentIdToBinary","hexHeads","stringifyAutomergeUrl","binaryToDocumentId","encodedDocumentId","isValidAutomergeUrl","isValidDocumentId","binaryDocumentID","Uuid.stringify","Uuid.validate","isValidUuid","generateAutomergeUrl","Uuid.v4","docId","encodeHeads","decodeHeads","interpretAsDocumentId","Uuid.parse","decoder","srcEnd","LEGACY_RECORD_INLINE_ID","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","PACKED_REFERENCE_TAG_ID","STOP_CODE","maxArraySize","maxMapSize","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","currentExtensionRanges","packedValues","restoreMapsAsObject","sequentialMode","inlineObjectReadThreshold","Decoder","rec","safeKey","saveState","clearSource","checkedRead","forEach","lastPosition","defaultDecoder","read","token","majorType","getFloat16","multiplier","mult10","readBin","shortStringInJS","longStringInJS","readFixedString","structure","createStructureReader","readJustLength","recordDefinition","readBundleExt","loadShared","extension","Tag","packedValue","getPackedValues","validName","readObject","compiledReader","readStringJS","units","byte1","byte2","byte3","byte4","unit","fromCharCode","g","f32Array","u8Array","byte0","exponent","abs","dateString","epochSec","fraction","existingStructure","glbl","packedTable","newPackedValues","startingPosition","refEntry","targetProperties","combine","SHARED_DATA_TAG_ID","isLittleEndianMachine","typedArrays","typedArrayTags","registerTypedArray","TypedArray","dvMethod","bytesPerElement","littleEndian","sizeShift","dv","elements","ta","method","bundlePosition","bundleLength","dataPosition","sharedData","updatedStructures","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","textEncoder","extensions","extensionClasses","Buffer","hasNodeBuffer","ByteArrayAllocate","ByteArray","MAX_STRUCTURES","MAX_BUFFER_SIZE","throwOnIterable","targetView","safeEnd","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Encoder","sharedStructures","hasSharedUpdate","structures","encodeUtf8","maxBytes","encoder","hasSharedStructures","maxSharedStructures","isSequential","samplingPackedValues","packedObjectMap","sharedValues","sharedPackedObjectMap","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","encodeOptions","REUSE_BUFFER_MODE","sharedStructuresLength","nextTransition","findRepetitiveStrings","writeArrayHeader","valuesArray","THROW_ON_ITERABLE","writeBundles","makeRoom","serialized","insertIds","returnBuffer","RESET_BUFFER_MODE","threshold","status","packedPosition","strLength","extStart","twoByte","headerSize","c1","c2","strPosition","useFloat32","xShifted","referee","idsToInsert","constructor","writeObject","entryValue","extensionClass","entry","isBlob","json","writeBuffer","objectOffset","skipValues","newTransitions","parentRecordId","recordId","newSize","newBuffer","chunkThreshold","continuedChunkThreshold","startEncoding","encodeObjectAsIterable","encodeObjectAsAsyncIterable","iterateProperties","finalIterable","useRecords","writeEntityLength","tryEncode","restartEncoding","restart","encodeIterable","encodedValue","reader","asyncValue","lastVersion","structuresCopy","SharedData","saveResults","existingShared","majorValue","version","BlobConstructor","packedStatus","includeKeys","date","seconds","arrayBuffer","typedArray","typedArrayEncoder","definitions","nextId","distanceToMove","lastEnd","writeStrings","defaultEncoder","cborXdecode","arraysAreEqual","element","headsAreSame","withTimeout","promise","timeoutId","timeoutPromise","reject","TimeoutError","DocHandle","#log","#machine","#fixedHeads","#prevDocState","A.init","#timeoutDelay","#syncInfoByStorageId","#viewCache","oldDoc","UPDATE","#checkForChanges","#doc","#state","#statePromise","awaitStates","awaitStatesArray","#sendUpdate","thrownException","beforeHeads","A.getHeads","afterHeads","A.diff","DOC_READY","A.view","BEGIN","A.topoHistoryTraversal","cacheKey","cachedHandle","A.clone","second","otherHeads","mergedDoc","A.merge","A.inspectChange","storageId","syncInfo","A.change","resultHeads","A.changeAt","otherHandle","mergingDoc","DOC_UNAVAILABLE","REQUEST","UNLOAD","RELOAD","DELETE","A.stats","HandleState","REQUESTING","READY","UNLOADED","DELETED","UNAVAILABLE","RemoteHeadsSubscriptions","#syncInfoByDocId","#ourSubscriptions","#theirSubscriptions","#generousPeers","#subscribedDocsByPeer","remotes","remotesToAdd","remotesToRemove","control","addedRemotesWeKnow","theirSubs","subscribedDocs","syncInfoForRemote","changedHeads","#changedHeads","peer","peerId","#isPeerSubscribedToDoc","timestamp","docRemote","lastHeads","lastSyncTimestamp","peerIds","remoteHeads","subscribedPeers","newHeads","throttle","lastCall","wait","isRepoMessage","isSyncMessage","isEphemeralMessage","isRequestMessage","isDocumentUnavailableMessage","isRemoteSubscriptionControlMessage","isRemoteHeadsChanged","getEphemeralMessageSource","NetworkSubsystem","#adaptersByPeer","#count","#sessionId","#ephemeralSessionCounts","adapters","peerMetadata","networkAdapter","outbound","mergeArrays","myArrays","mergedArray","factory","this","K","hashBlocks","dataLength","dataPos","bytesHashed","left","bitLenHi","bitLenLo","padLength","HMAC","digest","hmac","fillBuffer","info","counter","hkdfSalt","hkdf","salt","okm","hmac_","bufpos","pbkdf2","password","iterations","dkLen","prf","ctr","dk","keyHash","binary","sha256.hash","bufferToHexString","headsHash","headsbinary","StorageSubsystem","#storageAdapter","#storedHeads","#chunkInfos","#compacting","storageAdapter","storedId","storageKey","snapshotChunks","incrementalChunks","binaries","chunkInfos","chunk","newDoc","A.loadIncremental","#shouldSave","sourceChunks","#shouldCompact","#saveTotal","#saveIncremental","A.saveSince","A.save","snapshotHash","oldKeys","newChunkInfos","loaded","A.decodeSyncState","A.encodeSyncState","oldHeads","snapshotSize","incrementalSize","Synchronizer","DocSynchronizer","#peers","#pendingSyncStateCallbacks","#peerDocumentStatuses","#syncStates","#pendingSyncMessages","#peerId","#syncStarted","#handle","#onLoadSyncState","onLoadSyncState","#syncWithPeers","#broadcastToPeers","#processAllPendingSyncMessages","#sendSyncMessage","#sendEphemeralMessage","#withSyncState","#addPeer","pendingCallbacks","#initSyncState","A.initSyncState","#setSyncState","newSyncState","A.generateSyncMessage","isNew","#checkDocUnavailable","reparsedSyncState","noPeersWithDocument","senderId","contents","#processSyncMessage","A.decodeSyncMessage","A.receiveSyncMessage","log","CollectionSynchronizer","#docSetUp","#denylist","repo","denylist","#fetchDocSynchronizer","#initDocSynchronizer","docSynchronizer","isEphemeral","#documentGenerousPeers","peers","generousPeers","okToShare","synchronizer","abortable","settled","resolve","randomPeerId","Repo","#saveDebounceRate","#saveFn","#handleCache","#remoteHeadsSubscriptions","#remoteHeadsGossipingEnabled","#progressCache","storage","network","sharePolicy","enableRemoteHeadsGossiping","saveDebounceRate","storageSubsystem","networkSubsystem","saveFn","myPeerMetadata","shouldShare","#receiveMessage","#saveSyncState","#registerHandleWithSubsystems","#throttledSaveSyncStateHandlers","#getHandle","Automerge.from","Automerge.emptyChange","Automerge.init","clonedHandle","sourceDoc","Automerge.clone","cachedProgress","initial","progressSignal","progress","#loadDocumentWithProgress","abortPromise","loadingPromise","loadedDoc","unavailableProgress","allowableStates","unsubscribe","#loadDocument","Automerge.save","Automerge.load","documents","handles","adapter","NetworkAdapter","IndexedDBStorageAdapter","database","store","request","db","keyArray","transaction","keyPrefix","lowerBound","upperBound","ws","WebSocket$1","isPeerMessage","isErrorMessage","ProtocolV1","assert","trimLines","removeLine","targetText","line","toArrayBuffer","byteLength","WebSocketNetworkAdapter","WebSocketClientAdapter","#ready","#readyResolver","#readyPromise","#forceReady","#retryIntervalId","retryInterval","WebSocket","joinMessage","socket","encoded","cbor.encode","remotePeerId","messageBytes","cbor.decode","Automerge.initializeWasm","statusDiv","documentPre","updateButton","BrowserWebSocketClientAdapter","docUrl"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65]}